{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\siddharth\\\\Documents\\\\GitHub\\\\WhisperNet\\\\frontend\\\\src\\\\App.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useEffect } from 'react';\nimport io from 'socket.io-client';\nimport axios from 'axios';\nimport FingerprintJS from '@fingerprintjs/fingerprintjs';\n\n// Import components\nimport ConnectionInfo from './components/ConnectionInfo';\nimport SecurityAlert from './components/SecurityAlert';\nimport LoginScreen from './components/LoginScreen';\nimport ChatInterface from './components/ChatInterface';\nimport AboutPage from './components/AboutPage';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst BASE_NODE_URL = process.env.REACT_APP_BASE_NODE_URL || \"http://localhost:5000\";\n\n// Storage keys\nconst IDENTITY_STORAGE_KEY = 'whispernetKnownIdentities';\nconst CHAT_HISTORY_KEY = 'whispernetChatHistory';\nconst TRUST_STATUS_KEY = 'whispernetTrustStatus';\n\n// Encryption utilities\nconst generateKeyPair = async () => {\n  try {\n    const keyPair = await window.crypto.subtle.generateKey({\n      name: \"RSA-OAEP\",\n      modulusLength: 2048,\n      publicExponent: new Uint8Array([1, 0, 1]),\n      hash: \"SHA-256\"\n    }, true, [\"encrypt\", \"decrypt\"]);\n\n    // Export the keys to JWK format\n    const publicKey = await window.crypto.subtle.exportKey(\"jwk\", keyPair.publicKey);\n    const privateKey = await window.crypto.subtle.exportKey(\"jwk\", keyPair.privateKey);\n    return {\n      publicKey,\n      privateKey\n    };\n  } catch (error) {\n    console.error('Error generating key pair:', error);\n    throw error;\n  }\n};\nconst encryptMessage = async (message, publicKeyJwk) => {\n  try {\n    // Import the public key\n    const publicKey = await window.crypto.subtle.importKey(\"jwk\", publicKeyJwk, {\n      name: \"RSA-OAEP\",\n      hash: \"SHA-256\"\n    }, false, [\"encrypt\"]);\n\n    // Convert the message to an ArrayBuffer\n    const encoder = new TextEncoder();\n    const data = encoder.encode(message);\n\n    // Encrypt the data\n    const encryptedData = await window.crypto.subtle.encrypt({\n      name: \"RSA-OAEP\"\n    }, publicKey, data);\n\n    // Convert the encrypted data to a base64 string\n    return btoa(String.fromCharCode(...new Uint8Array(encryptedData)));\n  } catch (error) {\n    console.error('Error encrypting message:', error);\n    throw error;\n  }\n};\nconst decryptMessage = async (encryptedMessage, privateKeyJwk) => {\n  try {\n    // Import the private key\n    const privateKey = await window.crypto.subtle.importKey(\"jwk\", privateKeyJwk, {\n      name: \"RSA-OAEP\",\n      hash: \"SHA-256\"\n    }, false, [\"decrypt\"]);\n\n    // Convert the base64 string to an ArrayBuffer\n    const encryptedData = new Uint8Array(atob(encryptedMessage).split('').map(char => char.charCodeAt(0)));\n\n    // Decrypt the data\n    const decryptedData = await window.crypto.subtle.decrypt({\n      name: \"RSA-OAEP\"\n    }, privateKey, encryptedData);\n\n    // Convert the decrypted data to a string\n    const decoder = new TextDecoder();\n    return decoder.decode(decryptedData);\n  } catch (error) {\n    console.error('Error decrypting message:', error);\n    throw error;\n  }\n};\nfunction App() {\n  _s();\n  // Connection state\n  const [connected, setConnected] = useState(false);\n  const [username, setUsername] = useState('');\n  const [deviceId, setDeviceId] = useState('');\n  const [status, setStatus] = useState('Initializing...');\n  const [relayStatus, setRelayStatus] = useState('checking');\n  const [relayServerUrl, setRelayServerUrl] = useState('');\n  const [connectionDetails, setConnectionDetails] = useState({});\n  const [showConnectionInfo, setShowConnectionInfo] = useState(false);\n  const [securityAlert, setSecurityAlert] = useState(null);\n\n  // Message state\n  const [recipient, setRecipient] = useState('');\n  const [message, setMessage] = useState('');\n  const [messages, setMessages] = useState([]);\n  const [typing, setTyping] = useState(false);\n  const [onlineUsers, setOnlineUsers] = useState([]);\n  const [recipientStatus, setRecipientStatus] = useState({\n    exists: false,\n    online: false\n  });\n  const [isCheckingUsername, setIsCheckingUsername] = useState(false);\n  const [usernameAvailable, setUsernameAvailable] = useState(true);\n\n  // Encryption state\n  const [keyPair, setKeyPair] = useState(null);\n  const [publicKeys, setPublicKeys] = useState({});\n  const [encryptionEnabled, setEncryptionEnabled] = useState(true);\n  const [encryptionStatus, setEncryptionStatus] = useState('initializing');\n  const [knownIdentities, setKnownIdentities] = useState({}); // username -> {deviceId, publicKey, firstSeen}\n  const [identityMismatch, setIdentityMismatch] = useState(null); // {username, originalDeviceId, newDeviceId, action}\n  const [showIdentityWarning, setShowIdentityWarning] = useState(false);\n\n  // New state variables for enhanced chat functionality\n  const [chatHistory, setChatHistory] = useState({}); // username -> array of messages\n  const [contacts, setContacts] = useState([]); // list of usernames the current user has chatted with\n  const [activeChat, setActiveChat] = useState(null); // currently selected chat\n  const [trustStatus, setTrustStatus] = useState({}); // username -> {trusted: boolean, keyExchanged: boolean, mutualMessaging: boolean}\n  const [showTrustWarning, setShowTrustWarning] = useState(false); // whether to show the trust warning for the current chat\n\n  // UI state variables\n  const [showAboutPage, setShowAboutPage] = useState(false); // whether to show the About page\n\n  const socketRef = useRef(null);\n  const messagesEndRef = useRef(null);\n  const typingTimeoutRef = useRef(null);\n  const pingIntervalRef = useRef(null);\n  const recipientCheckTimeoutRef = useRef(null);\n\n  // Load known identities from localStorage\n  const loadKnownIdentities = () => {\n    try {\n      const storedIdentities = localStorage.getItem(IDENTITY_STORAGE_KEY);\n      if (storedIdentities) {\n        setKnownIdentities(JSON.parse(storedIdentities));\n      }\n    } catch (error) {\n      console.error('Error loading known identities:', error);\n    }\n  };\n\n  // Save known identities to localStorage\n  const saveKnownIdentities = identities => {\n    try {\n      localStorage.setItem(IDENTITY_STORAGE_KEY, JSON.stringify(identities));\n    } catch (error) {\n      console.error('Error saving known identities:', error);\n    }\n  };\n\n  // Load chat history from localStorage\n  const loadChatHistory = () => {\n    try {\n      const storedChatHistory = localStorage.getItem(CHAT_HISTORY_KEY);\n      if (storedChatHistory) {\n        const parsedChatHistory = JSON.parse(storedChatHistory);\n        setChatHistory(parsedChatHistory);\n\n        // Extract contacts from chat history\n        const contactsList = Object.keys(parsedChatHistory);\n        setContacts(contactsList);\n        console.log('Loaded chat history for contacts:', contactsList.length);\n\n        // If we have contacts but no active chat, set the first contact as active\n        if (contactsList.length > 0 && !activeChat) {\n          setActiveChat(contactsList[0]);\n          setRecipient(contactsList[0]);\n        }\n      }\n    } catch (error) {\n      console.error('Error loading chat history:', error);\n    }\n  };\n\n  // Save chat history to localStorage\n  const saveChatHistory = history => {\n    try {\n      localStorage.setItem(CHAT_HISTORY_KEY, JSON.stringify(history));\n    } catch (error) {\n      console.error('Error saving chat history:', error);\n    }\n  };\n\n  // Load trust status from localStorage\n  const loadTrustStatus = () => {\n    try {\n      const storedTrustStatus = localStorage.getItem(TRUST_STATUS_KEY);\n      if (storedTrustStatus) {\n        setTrustStatus(JSON.parse(storedTrustStatus));\n      }\n    } catch (error) {\n      console.error('Error loading trust status:', error);\n    }\n  };\n\n  // Save trust status to localStorage\n  const saveTrustStatus = status => {\n    try {\n      localStorage.setItem(TRUST_STATUS_KEY, JSON.stringify(status));\n    } catch (error) {\n      console.error('Error saving trust status:', error);\n    }\n  };\n\n  // Update chat history for a specific contact\n  const updateChatHistory = (contact, message) => {\n    setChatHistory(prevHistory => {\n      const updatedHistory = {\n        ...prevHistory\n      };\n\n      // Initialize chat history for this contact if it doesn't exist\n      if (!updatedHistory[contact]) {\n        updatedHistory[contact] = [];\n      }\n\n      // Add the message to the chat history\n      updatedHistory[contact] = [...updatedHistory[contact], message];\n\n      // Save the updated chat history\n      saveChatHistory(updatedHistory);\n\n      // Update contacts list if this is a new contact\n      if (!contacts.includes(contact)) {\n        const updatedContacts = [...contacts, contact];\n        setContacts(updatedContacts);\n      }\n      return updatedHistory;\n    });\n  };\n\n  // Check and update trust status for a contact\n  const updateTrustStatus = (contact, updates) => {\n    setTrustStatus(prevStatus => {\n      const updatedStatus = {\n        ...prevStatus\n      };\n\n      // Initialize trust status for this contact if it doesn't exist\n      if (!updatedStatus[contact]) {\n        updatedStatus[contact] = {\n          trusted: false,\n          keyExchanged: false,\n          mutualMessaging: false,\n          sentMessage: false,\n          receivedMessage: false,\n          firstInteraction: new Date().toISOString()\n        };\n      }\n\n      // Apply updates\n      updatedStatus[contact] = {\n        ...updatedStatus[contact],\n        ...updates\n      };\n\n      // Check if mutual messaging has occurred\n      if (updatedStatus[contact].sentMessage && updatedStatus[contact].receivedMessage) {\n        updatedStatus[contact].mutualMessaging = true;\n\n        // If mutual messaging has occurred and we have their public key, mark as trusted and exchange keys\n        if (publicKeys[contact]) {\n          updatedStatus[contact].keyExchanged = true;\n          updatedStatus[contact].trusted = true;\n\n          // Update the UI to show trust status change\n          if (contact === recipient) {\n            setShowTrustWarning(false);\n          }\n        }\n      } else {\n        // If we don't have mutual messaging yet, make sure to show the warning\n        if (contact === recipient) {\n          setShowTrustWarning(true);\n        }\n      }\n\n      // Save the updated trust status\n      saveTrustStatus(updatedStatus);\n      return updatedStatus;\n    });\n  };\n\n  // Initialize device fingerprint\n  useEffect(() => {\n    const initializeFingerprint = async () => {\n      try {\n        const fp = await FingerprintJS.load();\n        const result = await fp.get();\n        const deviceId = result.visitorId;\n        setDeviceId(deviceId);\n        console.log('Device fingerprint:', deviceId);\n      } catch (error) {\n        console.error('Error initializing fingerprint:', error);\n        setStatus('Error initializing device fingerprint');\n      }\n    };\n    initializeFingerprint();\n    loadKnownIdentities();\n    loadChatHistory();\n    loadTrustStatus();\n    checkRelayStatus();\n\n    // Scroll to bottom when messages change\n    if (messagesEndRef.current) {\n      messagesEndRef.current.scrollIntoView({\n        behavior: 'smooth'\n      });\n    }\n\n    // Add window unload handler to ensure username is released when browser is closed\n    const handleBeforeUnload = () => {\n      if (socketRef.current && socketRef.current.connected && username) {\n        // Synchronous logout call to ensure it happens before page unload\n        socketRef.current.emit('userLogout', {\n          username,\n          deviceId\n        });\n      }\n    };\n    window.addEventListener('beforeunload', handleBeforeUnload);\n    return () => {\n      // Clean up event listener\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n\n      // Logout and disconnect\n      if (socketRef.current && socketRef.current.connected && username) {\n        socketRef.current.emit('userLogout', {\n          username,\n          deviceId\n        });\n        socketRef.current.disconnect();\n      }\n      clearInterval(pingIntervalRef.current);\n      clearTimeout(recipientCheckTimeoutRef.current);\n      clearTimeout(typingTimeoutRef.current);\n    };\n  }, [username, deviceId]);\n\n  // Scroll to bottom when messages change\n  useEffect(() => {\n    if (messagesEndRef.current) {\n      messagesEndRef.current.scrollIntoView({\n        behavior: 'smooth'\n      });\n    }\n  }, [messages]);\n\n  // Update connection info when connection details change\n  useEffect(() => {\n    if (connected && showConnectionInfo) {\n      // Update connection info\n    }\n  }, [connected, showConnectionInfo, username]);\n  const checkRelayStatus = async () => {\n    setRelayStatus('checking');\n    setStatus('Checking base node status...');\n\n    // Try HTTP health check first\n    try {\n      const response = await axios.get(`${BASE_NODE_URL}/health`, {\n        timeout: 5000\n      });\n      if (response.status === 200) {\n        setRelayStatus('online');\n        setStatus('Base node online. Please login.');\n        return;\n      }\n    } catch (error) {\n      console.log('HTTP health check failed, trying socket connection:', error.message);\n    }\n\n    // Fallback to socket connection test\n    const tempSocket = io(BASE_NODE_URL, {\n      transports: ['websocket', 'polling'],\n      reconnectionAttempts: 2,\n      reconnectionDelay: 1000,\n      timeout: 5000,\n      forceNew: true\n    });\n    tempSocket.on('connect', () => {\n      console.log('Connected to base node for status check');\n      setRelayStatus('online');\n      setStatus('Base node online. Please login.');\n      tempSocket.disconnect();\n    });\n    tempSocket.on('connect_error', err => {\n      console.error('Base node connection error:', err);\n      setRelayStatus('offline');\n      setStatus('Base node offline. Please try again later.');\n      tempSocket.disconnect();\n    });\n  };\n\n  // Main socket connection effect\n  useEffect(() => {\n    if (connected && username && deviceId) {\n      connectToBaseNode();\n    }\n    return () => {\n      if (socketRef.current) {\n        clearInterval(pingIntervalRef.current);\n        clearTimeout(recipientCheckTimeoutRef.current);\n        clearTimeout(typingTimeoutRef.current);\n        socketRef.current.disconnect();\n        socketRef.current = null;\n      }\n    };\n  }, [connected, username, deviceId]);\n  const handleUsernameSubmit = async e => {\n    e.preventDefault();\n    if (!username.trim() || !deviceId) {\n      setStatus('Please enter a valid username');\n      return;\n    }\n    if (relayStatus !== 'online') {\n      setStatus('Cannot connect: Base node is offline');\n      return;\n    }\n    try {\n      setStatus('Checking username availability...');\n      setIsCheckingUsername(true);\n\n      // Skip username check if we're in development mode and the server is not responding\n      let usernameIsAvailable = true;\n      try {\n        // Check if username is available\n        const response = await axios.get(`${BASE_NODE_URL}/check-username/${username}`, {\n          timeout: 5000\n        });\n        usernameIsAvailable = response.data.available;\n      } catch (checkError) {\n        console.warn('Username check failed, proceeding anyway:', checkError);\n        // In case of error, we'll assume the username is available\n        // This allows development without the backend running\n      }\n      setIsCheckingUsername(false);\n      if (usernameIsAvailable) {\n        console.log('Username is available');\n        setUsernameAvailable(true);\n\n        // Generate encryption keys if needed\n        if (!keyPair) {\n          setStatus('Generating encryption keys...');\n          try {\n            const newKeyPair = await generateKeyPair();\n            setKeyPair(newKeyPair);\n            setEncryptionStatus('ready');\n            console.log('Encryption keys generated successfully');\n          } catch (error) {\n            console.error('Failed to generate encryption keys:', error);\n            setEncryptionStatus('failed');\n            setSecurityAlert({\n              username: 'System',\n              message: 'Failed to generate encryption keys. Messages will not be encrypted.',\n              type: 'error'\n            });\n          }\n        }\n        setConnected(true);\n        setStatus('Connecting to network...');\n      } else {\n        console.log('Username is already taken');\n        setUsernameAvailable(false);\n        setStatus('Username is already taken. Please choose another.');\n      }\n    } catch (error) {\n      console.error('Error in username submission process:', error);\n      setIsCheckingUsername(false);\n\n      // Allow login anyway in case of errors\n      setUsernameAvailable(true);\n      setConnected(true);\n      setStatus('Connecting to network (username check bypassed)...');\n    }\n  };\n  const handleUsernameChange = e => {\n    const newUsername = e.target.value.trim();\n    setUsername(newUsername);\n\n    // Reset availability check when username changes\n    setUsernameAvailable(true);\n\n    // Check username availability after a short delay\n    if (newUsername.length > 2) {\n      setIsCheckingUsername(true);\n      clearTimeout(window.usernameCheckTimeout);\n      window.usernameCheckTimeout = setTimeout(async () => {\n        try {\n          const response = await axios.get(`${BASE_NODE_URL}/check-username/${newUsername}`, {\n            timeout: 5000\n          });\n          setIsCheckingUsername(false);\n          setUsernameAvailable(response.data.available);\n        } catch (error) {\n          console.warn('Error checking username availability:', error);\n          // In case of error, assume username is available to allow development without backend\n          setIsCheckingUsername(false);\n          setUsernameAvailable(true);\n        }\n      }, 500);\n    } else {\n      setIsCheckingUsername(false);\n    }\n  };\n  const handleDisconnect = () => {\n    if (socketRef.current) {\n      // Explicitly notify the server that we're logging out\n      socketRef.current.emit('userLogout', {\n        username,\n        deviceId\n      }, response => {\n        console.log('Logout response:', response);\n        // Disconnect after logging out\n        socketRef.current.disconnect();\n      });\n\n      // Set a timeout to force disconnect in case the server doesn't respond\n      setTimeout(() => {\n        if (socketRef.current && socketRef.current.connected) {\n          socketRef.current.disconnect();\n        }\n      }, 1000);\n    }\n    setConnected(false);\n    setUsername('');\n    setMessages([]);\n    setStatus('Disconnected');\n    clearInterval(pingIntervalRef.current);\n    clearTimeout(recipientCheckTimeoutRef.current);\n    clearTimeout(typingTimeoutRef.current);\n  };\n  const connectToBaseNode = () => {\n    // Clear any previous connection\n    if (socketRef.current) {\n      // First try to logout to release the username\n      if (socketRef.current.connected) {\n        socketRef.current.emit('userLogout', {\n          username,\n          deviceId\n        }, () => {\n          socketRef.current.disconnect();\n          proceedWithBaseNodeConnection();\n        });\n\n        // Set a timeout in case the server doesn't respond\n        setTimeout(() => {\n          if (socketRef.current && socketRef.current.connected) {\n            socketRef.current.disconnect();\n            proceedWithBaseNodeConnection();\n          }\n        }, 1000);\n      } else {\n        socketRef.current.disconnect();\n        proceedWithBaseNodeConnection();\n      }\n    } else {\n      proceedWithBaseNodeConnection();\n    }\n    function proceedWithBaseNodeConnection() {\n      // Always connect to base node first for handshake and relay discovery\n      console.log('Connecting to base node for initial handshake:', BASE_NODE_URL);\n      setStatus('Connecting to base node for handshake...');\n      socketRef.current = io(BASE_NODE_URL, {\n        transports: ['websocket', 'polling'],\n        reconnectionAttempts: 3,\n        reconnectionDelay: 1000,\n        query: {\n          username,\n          deviceId,\n          publicKey: keyPair !== null && keyPair !== void 0 && keyPair.publicKey ? JSON.stringify(keyPair.publicKey) : null\n        },\n        auth: {\n          username,\n          deviceId\n        },\n        forceNew: true\n      });\n\n      // Connection event handlers\n      socketRef.current.on('connect', () => {\n        console.log('Connected to base node with socket ID:', socketRef.current.id);\n        setStatus('Connected to base node for handshake');\n        setRelayStatus('online');\n\n        // When connecting to the base node, set the relay information accordingly\n        setConnectionDetails({\n          socketId: socketRef.current.id,\n          transport: socketRef.current.io.engine.transport.name,\n          baseNodeUrl: BASE_NODE_URL,\n          relayId: 'base_handshake',\n          relayStatus: 'handshake'\n        });\n        setRelayServerUrl('Base Node (Handshake)');\n\n        // Register with the base node\n        socketRef.current.emit('registerUser', {\n          username,\n          deviceId,\n          publicKey: keyPair === null || keyPair === void 0 ? void 0 : keyPair.publicKey\n        }, response => {\n          console.log('Registration response:', response);\n          if (response && response.success) {\n            setStatus('Registered successfully with base node');\n\n            // Connect socket events\n            connectSocketEvents();\n\n            // Start ping interval\n            startPingInterval();\n\n            // Get available relays first\n            socketRef.current.emit('getAvailableRelays', {}, response => {\n              console.log('Available relays:', response);\n              if (response && response.relays && response.relays.length > 0) {\n                // Cache relay information\n                localStorage.setItem('whispernetRelayCache', JSON.stringify({\n                  timestamp: Date.now(),\n                  relays: response.relays\n                }));\n\n                // Connect to the first available relay\n                connectToRelay(response.relays);\n              } else {\n                console.log('No relays available, using base node');\n                setStatus('No relay servers available, using base node');\n\n                // Update connection details for direct base node connection\n                setRelayServerUrl('Base Node (Fallback)');\n                setConnectionDetails(prev => ({\n                  ...prev,\n                  relayId: 'direct',\n                  relayStatus: 'direct_to_base'\n                }));\n\n                // Start polling for available relays\n                startRelayPolling();\n              }\n            });\n          } else {\n            console.error('Registration failed:', (response === null || response === void 0 ? void 0 : response.reason) || 'Unknown error');\n            setStatus(`Registration failed: ${(response === null || response === void 0 ? void 0 : response.reason) || 'Unknown error'}`);\n          }\n        });\n      });\n    }\n    socketRef.current.on('connect_error', err => {\n      console.error('Base node connection error:', err);\n      setStatus(`Connection failed: ${err.message}`);\n      setRelayStatus('offline');\n\n      // Try to use cached relays if available\n      try {\n        const cachedRelayInfo = localStorage.getItem('whispernetRelayCache');\n        if (cachedRelayInfo) {\n          const relayInfo = JSON.parse(cachedRelayInfo);\n          const cacheAge = Date.now() - relayInfo.timestamp;\n\n          // Use cache if it's less than 1 hour old\n          if (cacheAge < 3600000 && relayInfo.relays && relayInfo.relays.length > 0) {\n            console.log('Using cached relay information');\n\n            // Try to connect to the first cached relay\n            connectToRelay(relayInfo.relays[0]);\n            return;\n          }\n        }\n      } catch (error) {\n        console.error('Error parsing cached relay info:', error);\n      }\n    });\n    socketRef.current.on('disconnect', reason => {\n      console.log('Disconnected from base node:', reason);\n      setStatus(`Disconnected: ${reason}`);\n\n      // Don't auto-reconnect if user manually disconnected\n      if (reason !== 'io client disconnect' && connected) {\n        setStatus('Reconnecting...');\n\n        // Try to reconnect after a delay\n        setTimeout(() => {\n          if (connected) {\n            connectToBaseNode();\n          }\n        }, 3000);\n      }\n    });\n  };\n  const connectToRelay = relays => {\n    if (!relays || !relays.length) {\n      console.log('No relays available to connect to');\n      return;\n    }\n\n    // Use the first available relay\n    const relay = relays[0];\n    const relayUrl = relay.url || relay.id && (relay.id.startsWith('http') ? relay.id : `http://${relay.id}`);\n    if (!relayUrl) {\n      console.error('Invalid relay information');\n      return;\n    }\n    console.log(`Switching to relay server: ${relayUrl}`);\n    setStatus(`Connecting to relay server: ${relay.id || relayUrl}...`);\n\n    // Disconnect from base node first\n    if (socketRef.current) {\n      // Keep a reference to the old socket for cleanup\n      const oldSocket = socketRef.current;\n\n      // Create new socket for relay\n      socketRef.current = io(relayUrl, {\n        transports: ['websocket', 'polling'],\n        reconnectionAttempts: 3,\n        reconnectionDelay: 2000,\n        query: {\n          username,\n          deviceId,\n          publicKey: keyPair !== null && keyPair !== void 0 && keyPair.publicKey ? JSON.stringify(keyPair.publicKey) : null\n        },\n        forceNew: true\n      });\n\n      // Set a timeout to disconnect from base node after relay connection is established\n      const relayConnectionTimeout = setTimeout(() => {\n        if (!socketRef.current || !socketRef.current.connected) {\n          console.log('Relay connection timed out, staying with base node');\n          socketRef.current = oldSocket; // Restore old socket\n          setStatus('Using Base Node (relay connection failed)');\n          setRelayServerUrl('Base Node (Fallback)');\n          setConnectionDetails(prev => ({\n            ...prev,\n            relayId: 'direct',\n            relayStatus: 'direct_to_base'\n          }));\n\n          // Start polling for available relays\n          startRelayPolling();\n        }\n      }, 5000);\n      socketRef.current.on('connect', () => {\n        clearTimeout(relayConnectionTimeout);\n        console.log(`Connected to relay server: ${relayUrl}`);\n\n        // Register with the relay\n        socketRef.current.emit('register', {\n          username,\n          deviceId,\n          publicKey: keyPair === null || keyPair === void 0 ? void 0 : keyPair.publicKey\n        }, response => {\n          if (response && response.success) {\n            console.log('Successfully registered with relay');\n\n            // Now we can safely disconnect from the base node\n            oldSocket.emit('userLogout', {\n              username,\n              deviceId\n            }, () => {\n              console.log('Logged out from base node after connecting to relay');\n              oldSocket.disconnect();\n            });\n            setStatus(`Connected to relay server: ${relay.id || relayUrl}`);\n            setRelayServerUrl(relay.id || relayUrl);\n            setConnectionDetails(prev => ({\n              ...prev,\n              relayId: relay.id || relayUrl,\n              socketId: socketRef.current.id,\n              transport: socketRef.current.io.engine.transport.name,\n              relayStatus: 'connected_to_relay',\n              ip: relay.ip,\n              port: relay.port,\n              connectedUsers: relay.connectedUsers\n            }));\n\n            // Set up socket event handlers\n            connectSocketEvents();\n\n            // Start ping interval\n            startPingInterval();\n\n            // Show connection info automatically\n            setShowConnectionInfo(true);\n            setTimeout(() => {\n              setShowConnectionInfo(false);\n            }, 5000);\n          } else {\n            console.error('Failed to register with relay:', response);\n            setStatus('Failed to register with relay server');\n\n            // Disconnect from relay and stay with base node\n            socketRef.current.disconnect();\n            socketRef.current = oldSocket;\n            setStatus('Using Base Node (relay registration failed)');\n            setRelayServerUrl('Base Node (Fallback)');\n            setConnectionDetails(prev => ({\n              ...prev,\n              relayId: 'direct',\n              relayStatus: 'direct_to_base'\n            }));\n\n            // Start polling for available relays\n            startRelayPolling();\n          }\n        });\n      });\n      socketRef.current.on('connect_error', err => {\n        clearTimeout(relayConnectionTimeout);\n        console.error(`Relay connection error: ${err.message}`);\n\n        // Stay with base node\n        socketRef.current = oldSocket;\n        setStatus('Using Base Node (relay connection failed)');\n        setRelayServerUrl('Base Node (Fallback)');\n        setConnectionDetails(prev => ({\n          ...prev,\n          relayId: 'direct',\n          relayStatus: 'direct_to_base'\n        }));\n\n        // Start polling for available relays\n        startRelayPolling();\n      });\n      socketRef.current.on('disconnect', reason => {\n        console.log(`Disconnected from relay: ${reason}`);\n\n        // If we were previously connected to a relay and lost connection\n        if (connectionDetails.relayStatus === 'connected_to_relay') {\n          setStatus(`Disconnected from relay: ${reason}`);\n\n          // Try to reconnect to base node\n          connectToBaseNode();\n        }\n      });\n    }\n  };\n  const startRelayPolling = () => {\n    // Clear any existing polling interval\n    if (window.relayPollingInterval) {\n      clearInterval(window.relayPollingInterval);\n    }\n\n    // Set up polling interval\n    window.relayPollingInterval = setInterval(() => {\n      if (socketRef.current && socketRef.current.connected && (connectionDetails.relayStatus === 'direct_to_base' || connectionDetails.relayId === 'direct')) {\n        console.log('Polling for available relays...');\n        socketRef.current.emit('getAvailableRelays', {}, response => {\n          if (response && response.relays && response.relays.length > 0) {\n            console.log('Found available relays:', response.relays);\n\n            // Cache relay information\n            localStorage.setItem('whispernetRelayCache', JSON.stringify({\n              timestamp: Date.now(),\n              relays: response.relays\n            }));\n\n            // Connect to the first available relay\n            connectToRelay(response.relays);\n\n            // Clear polling interval\n            clearInterval(window.relayPollingInterval);\n          } else {\n            console.log('No relays available, continuing to use base node');\n          }\n        });\n      }\n    }, 30000); // Poll every 30 seconds\n\n    // Clean up on component unmount\n    return () => {\n      if (window.relayPollingInterval) {\n        clearInterval(window.relayPollingInterval);\n      }\n    };\n  };\n  const connectSocketEvents = () => {\n    // Message handling\n    socketRef.current.on('receiveMessage', async data => {\n      console.log('Received message:', data);\n      const {\n        from,\n        message,\n        fromDeviceId,\n        timestamp,\n        encrypted,\n        publicKey,\n        bounced\n      } = data;\n\n      // Store sender's public key if provided\n      if (publicKey && from) {\n        console.log(`Storing public key for ${from}`);\n        setPublicKeys(prev => ({\n          ...prev,\n          [from]: publicKey\n        }));\n      }\n\n      // Security check for device ID changes\n      const previousMessages = messages.filter(msg => msg.from === from);\n      if (previousMessages.length > 0 && previousMessages[0].fromDeviceId && previousMessages[0].fromDeviceId !== fromDeviceId) {\n        setSecurityAlert({\n          username: from,\n          message: `Warning: ${from} appears to be messaging from a different device!`,\n          type: 'warning'\n        });\n      }\n      let decryptedMessage = message;\n      let decryptionStatus = 'plaintext';\n\n      // Decrypt the message if it's encrypted and we have our private key\n      if (encrypted && keyPair !== null && keyPair !== void 0 && keyPair.privateKey) {\n        try {\n          console.log('Decrypting message...');\n          decryptedMessage = await decryptMessage(message, keyPair.privateKey);\n          decryptionStatus = 'decrypted';\n          console.log('Message decrypted successfully');\n        } catch (error) {\n          console.error('Failed to decrypt message:', error);\n          decryptedMessage = '[Encrypted message - cannot decrypt]';\n          decryptionStatus = 'failed';\n          setSecurityAlert({\n            username: 'System',\n            message: `Failed to decrypt message from ${from}. Your keys may have changed.`,\n            type: 'warning'\n          });\n        }\n      }\n\n      // Create message object\n      const messageObj = {\n        from,\n        message: decryptedMessage,\n        fromDeviceId,\n        timestamp: new Date(timestamp || new Date()),\n        encrypted,\n        decryptionStatus,\n        bounced\n      };\n\n      // Add to messages array for current view\n      setMessages(msgs => [...msgs, messageObj]);\n\n      // Update chat history for this contact\n      updateChatHistory(from, messageObj);\n\n      // Update trust status - mark that we received a message from this user\n      updateTrustStatus(from, {\n        receivedMessage: true\n      });\n    });\n\n    // Handle public key requests\n    socketRef.current.on('publicKeyRequest', ({\n      from\n    }, ack) => {\n      console.log(`Public key requested by ${from}`);\n      if (keyPair && keyPair.publicKey) {\n        console.log(`Sending public key to ${from}`);\n        if (ack) ack({\n          success: true,\n          publicKey: keyPair.publicKey\n        });\n      } else {\n        console.warn('No public key available to share');\n        if (ack) ack({\n          success: false,\n          reason: 'Public key not available'\n        });\n      }\n    });\n\n    // User status updates\n    socketRef.current.on('userStatusUpdate', data => {\n      console.log('User status update:', data);\n      const {\n        username: user,\n        online\n      } = data;\n\n      // If this is our current recipient, update their status\n      if (user === recipient) {\n        console.log(`Updating status for current recipient ${user} to ${online ? 'online' : 'offline'}`);\n        setRecipientStatus(prev => ({\n          ...prev,\n          exists: true,\n          // If we got a status update, the user definitely exists\n          online,\n          notRegisteredYet: false // Clear this flag since we know the user exists\n        }));\n      }\n\n      // Update online users list\n      setOnlineUsers(prev => {\n        if (online && !prev.includes(user)) {\n          console.log(`Adding ${user} to online users list`);\n          return [...prev, user];\n        } else if (!online && prev.includes(user)) {\n          console.log(`Removing ${user} from online users list`);\n          return prev.filter(u => u !== user);\n        }\n        return prev;\n      });\n\n      // If we have a recipient, check if they're in the online users list\n      if (recipient) {\n        checkRecipientStatus();\n      }\n    });\n\n    // Handle bulk online users updates\n    socketRef.current.on('onlineUsersUpdate', data => {\n      console.log('Online users update:', data);\n      if (data && Array.isArray(data.users)) {\n        setOnlineUsers(data.users);\n\n        // If we have a recipient, check if they're in the online users list\n        if (recipient) {\n          const isOnline = data.users.includes(recipient);\n          console.log(`Recipient ${recipient} is ${isOnline ? 'online' : 'offline'}`);\n          setRecipientStatus(prev => ({\n            ...prev,\n            exists: prev.exists,\n            // Keep existing value\n            online: isOnline,\n            notRegisteredYet: false // Clear this flag since we got an update\n          }));\n        }\n      }\n    });\n\n    // Typing indicators\n    socketRef.current.on('userTyping', data => {\n      const {\n        username: typingUser\n      } = data;\n      if (typingUser === recipient) {\n        setTyping(true);\n        clearTimeout(typingTimeoutRef.current);\n        typingTimeoutRef.current = setTimeout(() => setTyping(false), 3000);\n      }\n    });\n\n    // Error handling\n    socketRef.current.on('error', error => {\n      console.error('Socket error:', error);\n      setSecurityAlert({\n        username: 'System',\n        message: `Connection error: ${error.message || 'Unknown error'}`,\n        type: 'error'\n      });\n    });\n\n    // Request online users list\n    if (socketRef.current && socketRef.current.connected) {\n      socketRef.current.emit('getOnlineUsers', {}, response => {\n        if (response && Array.isArray(response.users)) {\n          console.log('Online users:', response.users);\n          setOnlineUsers(response.users);\n        }\n      });\n    }\n  };\n  const startPingInterval = () => {\n    pingIntervalRef.current = setInterval(() => {\n      if (socketRef.current && socketRef.current.connected) {\n        // Send ping to keep connection alive\n        socketRef.current.emit('ping', {}, response => {\n          if (response) {\n            console.log('Ping response:', response);\n          }\n        });\n\n        // Request online users list\n        socketRef.current.emit('getOnlineUsers', {}, response => {\n          if (response && Array.isArray(response.users)) {\n            console.log('Online users:', response.users);\n            setOnlineUsers(response.users);\n          }\n        });\n      }\n    }, 30000); // Ping every 30 seconds\n  };\n  const checkRecipientStatus = () => {\n    if (!recipient || !socketRef.current || !socketRef.current.connected) {\n      return;\n    }\n    console.log(`Checking status for recipient: ${recipient}`);\n\n    // Check if the recipient is in the online users list\n    const isOnline = onlineUsers.includes(recipient);\n\n    // Check if the user exists\n    socketRef.current.emit('checkUser', {\n      username: recipient\n    }, response => {\n      console.log('Check user response:', response);\n      if (response && response.exists) {\n        setRecipientStatus({\n          exists: true,\n          online: isOnline,\n          notRegisteredYet: false\n        });\n      } else {\n        setRecipientStatus({\n          exists: false,\n          online: false,\n          notRegisteredYet: true\n        });\n      }\n    });\n  };\n  const handleRecipientChange = e => {\n    const newRecipient = e.target.value.trim();\n    setRecipient(newRecipient);\n    if (newRecipient) {\n      // Use a small delay to avoid too many checks while typing\n      if (recipientCheckTimeoutRef.current) {\n        clearTimeout(recipientCheckTimeoutRef.current);\n      }\n      recipientCheckTimeoutRef.current = setTimeout(() => {\n        checkRecipientStatus();\n      }, 500); // 500ms delay\n    }\n  };\n  const handleSend = async (e, bounce = false) => {\n    e.preventDefault();\n    if (!recipient || !message.trim() || !socketRef.current) return;\n    try {\n      // Show sending indicator\n      setStatus('Sending message...');\n\n      // If this is a relay/bounce message, we'll proceed regardless of recipient status\n      if (!bounce) {\n        // For direct messages, we need to check if the recipient exists and is online\n        const recipientOnline = recipientStatus.online;\n\n        // If recipient is not online, suggest using relay\n        if (!recipientOnline) {\n          setSecurityAlert({\n            username: 'System',\n            message: `${recipient} is offline or not found. Use the RELAY button to send a delayed message.`,\n            type: 'warning'\n          });\n          setStatus('Registered successfully');\n          return;\n        }\n      }\n\n      // Get recipient's public key if we don't have it and encryption is enabled\n      if (encryptionEnabled && !publicKeys[recipient]) {\n        try {\n          await requestPublicKey(recipient);\n        } catch (error) {\n          console.error('Failed to get public key:', error);\n          // Continue without encryption if we can't get the key\n        }\n      }\n      let finalMessage = message.trim();\n      let isEncrypted = false;\n\n      // Encrypt the message if encryption is enabled and we have the recipient's public key\n      if (encryptionEnabled && publicKeys[recipient]) {\n        try {\n          finalMessage = await encryptMessage(message.trim(), publicKeys[recipient]);\n          isEncrypted = true;\n          console.log('Message encrypted successfully');\n        } catch (error) {\n          console.error('Failed to encrypt message:', error);\n          setSecurityAlert({\n            username: 'System',\n            message: 'Failed to encrypt message. Sending as plaintext.',\n            type: 'warning'\n          });\n        }\n      }\n      const messageData = {\n        from: username,\n        // Add sender username\n        to: recipient,\n        message: finalMessage,\n        deviceId,\n        timestamp: new Date().toISOString(),\n        bounce: bounce,\n        // Always use the bounce parameter directly\n        encrypted: isEncrypted,\n        publicKey: keyPair === null || keyPair === void 0 ? void 0 : keyPair.publicKey // Send our public key with the message\n      };\n      console.log('Sending message:', {\n        ...messageData,\n        message: isEncrypted ? '[ENCRYPTED]' : finalMessage,\n        bounce: bounce\n      });\n\n      // Add a timeout to handle cases where the server doesn't respond\n      const messageTimeout = setTimeout(() => {\n        setSecurityAlert({\n          username: 'System',\n          message: 'Message sending timed out. Server may be offline.',\n          type: 'error'\n        });\n        setStatus('Registered successfully');\n      }, 10000);\n\n      // Use the correct event name based on whether we're connected to a relay or base node\n      const eventName = connectionDetails.relayStatus === 'connected_to_relay' ? 'sendMessage' : 'routeMessage';\n      socketRef.current.emit(eventName, messageData, response => {\n        clearTimeout(messageTimeout);\n        console.log('Send message response:', response);\n        setStatus('Registered successfully');\n        if (response && (response.delivered || response.bounced)) {\n          // Create message object\n          const messageObj = {\n            from: username,\n            message: message.trim(),\n            // Store original message for display\n            fromDeviceId: deviceId,\n            timestamp: new Date(),\n            status: response.delivered ? 'delivered' : 'bounced',\n            expiresAt: response.expiresAt,\n            encrypted: isEncrypted\n          };\n\n          // Add message to local state (store original message for display)\n          setMessages(msgs => [...msgs, messageObj]);\n\n          // Update chat history for this contact\n          updateChatHistory(recipient, messageObj);\n\n          // Update trust status - mark that we sent a message to this user\n          updateTrustStatus(recipient, {\n            sentMessage: true\n          });\n          setMessage('');\n\n          // Show notification if message was bounced\n          if (response.bounced) {\n            setSecurityAlert({\n              username: 'System',\n              message: `Message to ${recipient} will be delivered when they come online (expires in 4 hours)`,\n              type: 'info'\n            });\n          }\n        } else {\n          const errorMsg = (response === null || response === void 0 ? void 0 : response.reason) || 'Message delivery failed';\n          if (errorMsg.includes('not found') || errorMsg.includes('User not found')) {\n            if (bounce) {\n              // For bounced messages to non-existent users, show a special message\n              setSecurityAlert({\n                username: 'System',\n                message: `Message will be delivered if ${recipient} registers within 4 hours.`,\n                type: 'info'\n              });\n\n              // Create message object\n              const messageObj = {\n                from: username,\n                message: message.trim(),\n                fromDeviceId: deviceId,\n                timestamp: new Date(),\n                status: 'bounced',\n                expiresAt: Date.now() + 14400000,\n                // 4 hours\n                encrypted: isEncrypted\n              };\n\n              // Add message to local state as bounced\n              setMessages(msgs => [...msgs, messageObj]);\n\n              // Update chat history for this contact\n              updateChatHistory(recipient, messageObj);\n\n              // Update trust status - mark that we sent a message to this user\n              updateTrustStatus(recipient, {\n                sentMessage: true\n              });\n              setMessage('');\n            } else {\n              setSecurityAlert({\n                username: 'System',\n                message: `${recipient} not found. Use the RELAY button to send a message that will be delivered if they register.`,\n                type: 'warning'\n              });\n            }\n          } else if (errorMsg.includes('offline')) {\n            setSecurityAlert({\n              username: 'System',\n              message: `${recipient} is offline. Use the RELAY button to send a delayed message.`,\n              type: 'warning'\n            });\n          } else {\n            setSecurityAlert({\n              username: 'System',\n              message: `Failed to send message: ${errorMsg}`,\n              type: 'error'\n            });\n          }\n        }\n      });\n    } catch (error) {\n      console.error('Error sending message:', error);\n      setSecurityAlert({\n        username: 'System',\n        message: `Error sending message: ${error.message}`,\n        type: 'error'\n      });\n      setStatus('Registered successfully');\n    }\n  };\n\n  // Request public key from a user\n  const requestPublicKey = async username => {\n    return new Promise((resolve, reject) => {\n      if (!socketRef.current) {\n        reject(new Error('Not connected'));\n        return;\n      }\n      console.log(`Requesting public key for ${username}...`);\n\n      // Set a timeout in case the server doesn't respond\n      const requestTimeout = setTimeout(() => {\n        console.error(`Public key request for ${username} timed out`);\n        reject(new Error('Request timed out'));\n      }, 10000);\n      socketRef.current.emit('requestPublicKey', {\n        username\n      }, response => {\n        clearTimeout(requestTimeout);\n        if (response && response.success && response.publicKey) {\n          console.log(`Received public key for ${username}`);\n          setPublicKeys(prev => ({\n            ...prev,\n            [username]: response.publicKey\n          }));\n          resolve(response.publicKey);\n        } else {\n          const reason = (response === null || response === void 0 ? void 0 : response.reason) || 'Public key not available';\n          console.log(`No public key available for ${username}: ${reason}`);\n          reject(new Error(reason));\n        }\n      });\n    });\n  };\n  const handleBounce = e => {\n    if (!recipient || !message.trim()) {\n      return;\n    }\n\n    // Show confirmation before bouncing\n    const confirmBounce = window.confirm(`RELAY MESSAGE\\n\\n` + `Your message to \"${recipient}\" will be stored on ${connectionDetails.relayStatus === 'connected_to_relay' ? 'relay' : 'base node'} servers for up to 4 hours.\\n\\n` + `It will be delivered when ${recipient} comes online or registers with the network.\\n\\n` + `Continue?`);\n    if (confirmBounce) {\n      handleSend(e, true);\n    }\n  };\n  const handleMessageChange = e => {\n    setMessage(e.target.value);\n\n    // Send typing indicator\n    if (socketRef.current && recipient && e.target.value.length > 0) {\n      socketRef.current.emit('typing', {\n        to: recipient\n      });\n    }\n  };\n  const dismissAlert = () => {\n    setSecurityAlert(null);\n  };\n  const retryConnection = () => {\n    checkRelayStatus();\n  };\n\n  // Utility functions\n  const getTimestamp = () => {\n    const now = new Date();\n    return `[${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}]`;\n  };\n  const formatMessageTime = timestamp => {\n    if (!timestamp) return getTimestamp();\n    const date = new Date(timestamp);\n    return `[${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}]`;\n  };\n\n  // Function to switch to a specific chat\n  const switchToChat = contactUsername => {\n    setActiveChat(contactUsername);\n    setRecipient(contactUsername || '');\n\n    // Load messages for this contact\n    if (contactUsername && chatHistory[contactUsername]) {\n      setMessages(chatHistory[contactUsername]);\n    } else {\n      setMessages([]);\n    }\n\n    // Check if we need to show trust warning\n    if (contactUsername && trustStatus[contactUsername]) {\n      setShowTrustWarning(!trustStatus[contactUsername].mutualMessaging);\n    } else if (contactUsername) {\n      setShowTrustWarning(true);\n    } else {\n      setShowTrustWarning(false);\n    }\n  };\n\n  // Function to toggle About page\n  const toggleAboutPage = () => {\n    setShowAboutPage(!showAboutPage);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      background: '#0a0e14',\n      minHeight: '100vh',\n      color: '#a2aabc',\n      display: 'flex',\n      flexDirection: 'column',\n      fontFamily: '\"Fira Code\", monospace'\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"header\", {\n      style: {\n        background: '#171c28',\n        padding: '16px 24px',\n        borderBottom: '1px solid rgba(0, 255, 170, 0.3)',\n        display: 'flex',\n        justifyContent: 'space-between',\n        alignItems: 'center'\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          display: 'flex',\n          alignItems: 'center'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n          style: {\n            margin: 0,\n            color: '#5ccfe6',\n            fontFamily: '\"Fira Code\", monospace',\n            letterSpacing: '1px',\n            fontSize: '24px'\n          },\n          children: \"WhisperNet_\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1476,\n          columnNumber: 11\n        }, this), username && /*#__PURE__*/_jsxDEV(\"span\", {\n          style: {\n            marginLeft: '16px',\n            color: '#bae67e',\n            fontSize: '14px',\n            padding: '4px 8px',\n            background: 'rgba(186, 230, 126, 0.1)',\n            borderRadius: '4px'\n          },\n          children: [\"@\", username]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1485,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1475,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          display: 'flex',\n          alignItems: 'center'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            fontSize: 12,\n            padding: '4px 8px',\n            borderRadius: 4,\n            background: relayStatus === 'online' ? '#1c4b3c' : '#4b1c1c',\n            color: relayStatus === 'online' ? '#5ccfe6' : '#ff8f40',\n            cursor: 'pointer',\n            marginRight: '12px'\n          },\n          onClick: () => setShowConnectionInfo(!showConnectionInfo),\n          children: relayStatus === 'online' ? 'Base Node Online' : relayStatus === 'checking' ? 'Checking...' : 'Base Node Offline'\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1499,\n          columnNumber: 11\n        }, this), connected && /*#__PURE__*/_jsxDEV(\"button\", {\n          style: {\n            padding: '8px 16px',\n            borderRadius: 4,\n            background: '#4b1c1c',\n            color: '#ff8f40',\n            fontSize: 14,\n            border: 'none',\n            cursor: 'pointer',\n            fontFamily: '\"Fira Code\", monospace',\n            marginRight: '12px'\n          },\n          onClick: handleDisconnect,\n          children: \"DISCONNECT\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1513,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          style: {\n            padding: '8px 16px',\n            borderRadius: 4,\n            background: '#1c3b4b',\n            color: '#5ccfe6',\n            fontSize: 14,\n            border: 'none',\n            cursor: 'pointer',\n            fontFamily: '\"Fira Code\", monospace'\n          },\n          onClick: toggleAboutPage,\n          children: showAboutPage ? 'BACK TO CHAT' : 'ABOUT'\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1531,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1498,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1467,\n      columnNumber: 7\n    }, this), showConnectionInfo && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        padding: '0 24px'\n      },\n      children: /*#__PURE__*/_jsxDEV(ConnectionInfo, {\n        status: status,\n        connected: connected,\n        connectionDetails: connectionDetails,\n        relayServerUrl: relayServerUrl,\n        relayStatus: relayStatus,\n        deviceId: deviceId,\n        BASE_NODE_URL: BASE_NODE_URL\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1552,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1551,\n      columnNumber: 9\n    }, this), securityAlert && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        padding: '0 24px'\n      },\n      children: /*#__PURE__*/_jsxDEV(SecurityAlert, {\n        alert: securityAlert,\n        onDismiss: dismissAlert\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1567,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1566,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        flex: 1,\n        display: 'flex',\n        height: 'calc(100vh - 69px - (showConnectionInfo ? 80 : 0) - (securityAlert ? 60 : 0))' // Subtract header height and optional elements\n      },\n      children: showAboutPage ? /*#__PURE__*/_jsxDEV(AboutPage, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1578,\n        columnNumber: 11\n      }, this) : !connected ? /*#__PURE__*/_jsxDEV(LoginScreen, {\n        username: username,\n        handleUsernameChange: handleUsernameChange,\n        handleUsernameSubmit: handleUsernameSubmit,\n        isCheckingUsername: isCheckingUsername,\n        usernameAvailable: usernameAvailable,\n        relayStatus: relayStatus,\n        status: status,\n        securityAlert: securityAlert,\n        dismissAlert: dismissAlert,\n        retryConnection: retryConnection,\n        getTimestamp: getTimestamp\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1580,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(ChatInterface, {\n        contacts: contacts,\n        activeChat: activeChat,\n        switchToChat: switchToChat,\n        onlineUsers: onlineUsers,\n        trustStatus: trustStatus,\n        recipient: recipient,\n        handleRecipientChange: handleRecipientChange,\n        message: message,\n        handleMessageChange: handleMessageChange,\n        handleSend: handleSend,\n        handleBounce: handleBounce,\n        recipientStatus: recipientStatus,\n        messages: messages,\n        username: username,\n        typing: typing,\n        messagesEndRef: messagesEndRef,\n        formatMessageTime: formatMessageTime,\n        getTimestamp: getTimestamp,\n        showTrustWarning: showTrustWarning\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1594,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1572,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1458,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"k1FAj4IO3rcy5/+VwcZ4YOdbLA4=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useRef","useEffect","io","axios","FingerprintJS","ConnectionInfo","SecurityAlert","LoginScreen","ChatInterface","AboutPage","jsxDEV","_jsxDEV","BASE_NODE_URL","process","env","REACT_APP_BASE_NODE_URL","IDENTITY_STORAGE_KEY","CHAT_HISTORY_KEY","TRUST_STATUS_KEY","generateKeyPair","keyPair","window","crypto","subtle","generateKey","name","modulusLength","publicExponent","Uint8Array","hash","publicKey","exportKey","privateKey","error","console","encryptMessage","message","publicKeyJwk","importKey","encoder","TextEncoder","data","encode","encryptedData","encrypt","btoa","String","fromCharCode","decryptMessage","encryptedMessage","privateKeyJwk","atob","split","map","char","charCodeAt","decryptedData","decrypt","decoder","TextDecoder","decode","App","_s","connected","setConnected","username","setUsername","deviceId","setDeviceId","status","setStatus","relayStatus","setRelayStatus","relayServerUrl","setRelayServerUrl","connectionDetails","setConnectionDetails","showConnectionInfo","setShowConnectionInfo","securityAlert","setSecurityAlert","recipient","setRecipient","setMessage","messages","setMessages","typing","setTyping","onlineUsers","setOnlineUsers","recipientStatus","setRecipientStatus","exists","online","isCheckingUsername","setIsCheckingUsername","usernameAvailable","setUsernameAvailable","setKeyPair","publicKeys","setPublicKeys","encryptionEnabled","setEncryptionEnabled","encryptionStatus","setEncryptionStatus","knownIdentities","setKnownIdentities","identityMismatch","setIdentityMismatch","showIdentityWarning","setShowIdentityWarning","chatHistory","setChatHistory","contacts","setContacts","activeChat","setActiveChat","trustStatus","setTrustStatus","showTrustWarning","setShowTrustWarning","showAboutPage","setShowAboutPage","socketRef","messagesEndRef","typingTimeoutRef","pingIntervalRef","recipientCheckTimeoutRef","loadKnownIdentities","storedIdentities","localStorage","getItem","JSON","parse","saveKnownIdentities","identities","setItem","stringify","loadChatHistory","storedChatHistory","parsedChatHistory","contactsList","Object","keys","log","length","saveChatHistory","history","loadTrustStatus","storedTrustStatus","saveTrustStatus","updateChatHistory","contact","prevHistory","updatedHistory","includes","updatedContacts","updateTrustStatus","updates","prevStatus","updatedStatus","trusted","keyExchanged","mutualMessaging","sentMessage","receivedMessage","firstInteraction","Date","toISOString","initializeFingerprint","fp","load","result","get","visitorId","checkRelayStatus","current","scrollIntoView","behavior","handleBeforeUnload","emit","addEventListener","removeEventListener","disconnect","clearInterval","clearTimeout","response","timeout","tempSocket","transports","reconnectionAttempts","reconnectionDelay","forceNew","on","err","connectToBaseNode","handleUsernameSubmit","e","preventDefault","trim","usernameIsAvailable","available","checkError","warn","newKeyPair","type","handleUsernameChange","newUsername","target","value","usernameCheckTimeout","setTimeout","handleDisconnect","proceedWithBaseNodeConnection","query","auth","id","socketId","transport","engine","baseNodeUrl","relayId","success","connectSocketEvents","startPingInterval","relays","timestamp","now","connectToRelay","prev","startRelayPolling","reason","cachedRelayInfo","relayInfo","cacheAge","relay","relayUrl","url","startsWith","oldSocket","relayConnectionTimeout","ip","port","connectedUsers","relayPollingInterval","setInterval","from","fromDeviceId","encrypted","bounced","previousMessages","filter","msg","decryptedMessage","decryptionStatus","messageObj","msgs","ack","user","notRegisteredYet","u","checkRecipientStatus","Array","isArray","users","isOnline","typingUser","handleRecipientChange","newRecipient","handleSend","bounce","recipientOnline","requestPublicKey","finalMessage","isEncrypted","messageData","to","messageTimeout","eventName","delivered","expiresAt","errorMsg","Promise","resolve","reject","Error","requestTimeout","handleBounce","confirmBounce","confirm","handleMessageChange","dismissAlert","retryConnection","getTimestamp","getHours","toString","padStart","getMinutes","getSeconds","formatMessageTime","date","switchToChat","contactUsername","toggleAboutPage","style","background","minHeight","color","display","flexDirection","fontFamily","children","padding","borderBottom","justifyContent","alignItems","margin","letterSpacing","fontSize","fileName","_jsxFileName","lineNumber","columnNumber","marginLeft","borderRadius","cursor","marginRight","onClick","border","alert","onDismiss","flex","height","_c","$RefreshReg$"],"sources":["C:/Users/siddharth/Documents/GitHub/WhisperNet/frontend/src/App.js"],"sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\r\nimport io from 'socket.io-client';\r\nimport axios from 'axios';\r\nimport FingerprintJS from '@fingerprintjs/fingerprintjs';\r\n\r\n// Import components\r\nimport ConnectionInfo from './components/ConnectionInfo';\r\nimport SecurityAlert from './components/SecurityAlert';\r\nimport LoginScreen from './components/LoginScreen';\r\nimport ChatInterface from './components/ChatInterface';\r\nimport AboutPage from './components/AboutPage';\r\n\r\nconst BASE_NODE_URL = process.env.REACT_APP_BASE_NODE_URL || \"http://localhost:5000\";\r\n\r\n// Storage keys\r\nconst IDENTITY_STORAGE_KEY = 'whispernetKnownIdentities';\r\nconst CHAT_HISTORY_KEY = 'whispernetChatHistory';\r\nconst TRUST_STATUS_KEY = 'whispernetTrustStatus';\r\n\r\n// Encryption utilities\r\nconst generateKeyPair = async () => {\r\n  try {\r\n    const keyPair = await window.crypto.subtle.generateKey(\r\n      {\r\n        name: \"RSA-OAEP\",\r\n        modulusLength: 2048,\r\n        publicExponent: new Uint8Array([1, 0, 1]),\r\n        hash: \"SHA-256\",\r\n      },\r\n      true,\r\n      [\"encrypt\", \"decrypt\"]\r\n    );\r\n    \r\n    // Export the keys to JWK format\r\n    const publicKey = await window.crypto.subtle.exportKey(\"jwk\", keyPair.publicKey);\r\n    const privateKey = await window.crypto.subtle.exportKey(\"jwk\", keyPair.privateKey);\r\n    \r\n    return { publicKey, privateKey };\r\n  } catch (error) {\r\n    console.error('Error generating key pair:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nconst encryptMessage = async (message, publicKeyJwk) => {\r\n  try {\r\n    // Import the public key\r\n    const publicKey = await window.crypto.subtle.importKey(\r\n      \"jwk\",\r\n      publicKeyJwk,\r\n      {\r\n        name: \"RSA-OAEP\",\r\n        hash: \"SHA-256\",\r\n      },\r\n      false,\r\n      [\"encrypt\"]\r\n    );\r\n    \r\n    // Convert the message to an ArrayBuffer\r\n    const encoder = new TextEncoder();\r\n    const data = encoder.encode(message);\r\n    \r\n    // Encrypt the data\r\n    const encryptedData = await window.crypto.subtle.encrypt(\r\n      {\r\n        name: \"RSA-OAEP\"\r\n      },\r\n      publicKey,\r\n      data\r\n    );\r\n    \r\n    // Convert the encrypted data to a base64 string\r\n    return btoa(String.fromCharCode(...new Uint8Array(encryptedData)));\r\n  } catch (error) {\r\n    console.error('Error encrypting message:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nconst decryptMessage = async (encryptedMessage, privateKeyJwk) => {\r\n  try {\r\n    // Import the private key\r\n    const privateKey = await window.crypto.subtle.importKey(\r\n      \"jwk\",\r\n      privateKeyJwk,\r\n      {\r\n        name: \"RSA-OAEP\",\r\n        hash: \"SHA-256\",\r\n      },\r\n      false,\r\n      [\"decrypt\"]\r\n    );\r\n    \r\n    // Convert the base64 string to an ArrayBuffer\r\n    const encryptedData = new Uint8Array(\r\n      atob(encryptedMessage)\r\n        .split('')\r\n        .map(char => char.charCodeAt(0))\r\n    );\r\n    \r\n    // Decrypt the data\r\n    const decryptedData = await window.crypto.subtle.decrypt(\r\n      {\r\n        name: \"RSA-OAEP\"\r\n      },\r\n      privateKey,\r\n      encryptedData\r\n    );\r\n    \r\n    // Convert the decrypted data to a string\r\n    const decoder = new TextDecoder();\r\n    return decoder.decode(decryptedData);\r\n  } catch (error) {\r\n    console.error('Error decrypting message:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nfunction App() {\r\n  // Connection state\r\n  const [connected, setConnected] = useState(false);\r\n  const [username, setUsername] = useState('');\r\n  const [deviceId, setDeviceId] = useState('');\r\n  const [status, setStatus] = useState('Initializing...');\r\n  const [relayStatus, setRelayStatus] = useState('checking');\r\n  const [relayServerUrl, setRelayServerUrl] = useState('');\r\n  const [connectionDetails, setConnectionDetails] = useState({});\r\n  const [showConnectionInfo, setShowConnectionInfo] = useState(false);\r\n  const [securityAlert, setSecurityAlert] = useState(null);\r\n  \r\n  // Message state\r\n  const [recipient, setRecipient] = useState('');\r\n  const [message, setMessage] = useState('');\r\n  const [messages, setMessages] = useState([]);\r\n  const [typing, setTyping] = useState(false);\r\n  const [onlineUsers, setOnlineUsers] = useState([]);\r\n  const [recipientStatus, setRecipientStatus] = useState({ exists: false, online: false });\r\n  const [isCheckingUsername, setIsCheckingUsername] = useState(false);\r\n  const [usernameAvailable, setUsernameAvailable] = useState(true);\r\n  \r\n  // Encryption state\r\n  const [keyPair, setKeyPair] = useState(null);\r\n  const [publicKeys, setPublicKeys] = useState({});\r\n  const [encryptionEnabled, setEncryptionEnabled] = useState(true);\r\n  const [encryptionStatus, setEncryptionStatus] = useState('initializing');\r\n  const [knownIdentities, setKnownIdentities] = useState({}); // username -> {deviceId, publicKey, firstSeen}\r\n  const [identityMismatch, setIdentityMismatch] = useState(null); // {username, originalDeviceId, newDeviceId, action}\r\n  const [showIdentityWarning, setShowIdentityWarning] = useState(false);\r\n  \r\n  // New state variables for enhanced chat functionality\r\n  const [chatHistory, setChatHistory] = useState({}); // username -> array of messages\r\n  const [contacts, setContacts] = useState([]); // list of usernames the current user has chatted with\r\n  const [activeChat, setActiveChat] = useState(null); // currently selected chat\r\n  const [trustStatus, setTrustStatus] = useState({}); // username -> {trusted: boolean, keyExchanged: boolean, mutualMessaging: boolean}\r\n  const [showTrustWarning, setShowTrustWarning] = useState(false); // whether to show the trust warning for the current chat\r\n  \r\n  // UI state variables\r\n  const [showAboutPage, setShowAboutPage] = useState(false); // whether to show the About page\r\n  \r\n  const socketRef = useRef(null);\r\n  const messagesEndRef = useRef(null);\r\n  const typingTimeoutRef = useRef(null);\r\n  const pingIntervalRef = useRef(null);\r\n  const recipientCheckTimeoutRef = useRef(null);\r\n\r\n  // Load known identities from localStorage\r\n  const loadKnownIdentities = () => {\r\n    try {\r\n      const storedIdentities = localStorage.getItem(IDENTITY_STORAGE_KEY);\r\n      if (storedIdentities) {\r\n        setKnownIdentities(JSON.parse(storedIdentities));\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading known identities:', error);\r\n    }\r\n  };\r\n  \r\n  // Save known identities to localStorage\r\n  const saveKnownIdentities = (identities) => {\r\n    try {\r\n      localStorage.setItem(IDENTITY_STORAGE_KEY, JSON.stringify(identities));\r\n    } catch (error) {\r\n      console.error('Error saving known identities:', error);\r\n    }\r\n  };\r\n  \r\n  // Load chat history from localStorage\r\n  const loadChatHistory = () => {\r\n    try {\r\n      const storedChatHistory = localStorage.getItem(CHAT_HISTORY_KEY);\r\n      if (storedChatHistory) {\r\n        const parsedChatHistory = JSON.parse(storedChatHistory);\r\n        setChatHistory(parsedChatHistory);\r\n        \r\n        // Extract contacts from chat history\r\n        const contactsList = Object.keys(parsedChatHistory);\r\n        setContacts(contactsList);\r\n        console.log('Loaded chat history for contacts:', contactsList.length);\r\n        \r\n        // If we have contacts but no active chat, set the first contact as active\r\n        if (contactsList.length > 0 && !activeChat) {\r\n          setActiveChat(contactsList[0]);\r\n          setRecipient(contactsList[0]);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading chat history:', error);\r\n    }\r\n  };\r\n  \r\n  // Save chat history to localStorage\r\n  const saveChatHistory = (history) => {\r\n    try {\r\n      localStorage.setItem(CHAT_HISTORY_KEY, JSON.stringify(history));\r\n    } catch (error) {\r\n      console.error('Error saving chat history:', error);\r\n    }\r\n  };\r\n  \r\n  // Load trust status from localStorage\r\n  const loadTrustStatus = () => {\r\n    try {\r\n      const storedTrustStatus = localStorage.getItem(TRUST_STATUS_KEY);\r\n      if (storedTrustStatus) {\r\n        setTrustStatus(JSON.parse(storedTrustStatus));\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading trust status:', error);\r\n    }\r\n  };\r\n  \r\n  // Save trust status to localStorage\r\n  const saveTrustStatus = (status) => {\r\n    try {\r\n      localStorage.setItem(TRUST_STATUS_KEY, JSON.stringify(status));\r\n    } catch (error) {\r\n      console.error('Error saving trust status:', error);\r\n    }\r\n  };\r\n  \r\n  // Update chat history for a specific contact\r\n  const updateChatHistory = (contact, message) => {\r\n    setChatHistory(prevHistory => {\r\n      const updatedHistory = { ...prevHistory };\r\n      \r\n      // Initialize chat history for this contact if it doesn't exist\r\n      if (!updatedHistory[contact]) {\r\n        updatedHistory[contact] = [];\r\n      }\r\n      \r\n      // Add the message to the chat history\r\n      updatedHistory[contact] = [...updatedHistory[contact], message];\r\n      \r\n      // Save the updated chat history\r\n      saveChatHistory(updatedHistory);\r\n      \r\n      // Update contacts list if this is a new contact\r\n      if (!contacts.includes(contact)) {\r\n        const updatedContacts = [...contacts, contact];\r\n        setContacts(updatedContacts);\r\n      }\r\n      \r\n      return updatedHistory;\r\n    });\r\n  };\r\n  \r\n  // Check and update trust status for a contact\r\n  const updateTrustStatus = (contact, updates) => {\r\n    setTrustStatus(prevStatus => {\r\n      const updatedStatus = { ...prevStatus };\r\n      \r\n      // Initialize trust status for this contact if it doesn't exist\r\n      if (!updatedStatus[contact]) {\r\n        updatedStatus[contact] = {\r\n          trusted: false,\r\n          keyExchanged: false,\r\n          mutualMessaging: false,\r\n          sentMessage: false,\r\n          receivedMessage: false,\r\n          firstInteraction: new Date().toISOString()\r\n        };\r\n      }\r\n      \r\n      // Apply updates\r\n      updatedStatus[contact] = {\r\n        ...updatedStatus[contact],\r\n        ...updates\r\n      };\r\n      \r\n      // Check if mutual messaging has occurred\r\n      if (updatedStatus[contact].sentMessage && updatedStatus[contact].receivedMessage) {\r\n        updatedStatus[contact].mutualMessaging = true;\r\n        \r\n        // If mutual messaging has occurred and we have their public key, mark as trusted and exchange keys\r\n        if (publicKeys[contact]) {\r\n          updatedStatus[contact].keyExchanged = true;\r\n          updatedStatus[contact].trusted = true;\r\n          \r\n          // Update the UI to show trust status change\r\n          if (contact === recipient) {\r\n            setShowTrustWarning(false);\r\n          }\r\n        }\r\n      } else {\r\n        // If we don't have mutual messaging yet, make sure to show the warning\r\n        if (contact === recipient) {\r\n          setShowTrustWarning(true);\r\n        }\r\n      }\r\n      \r\n      // Save the updated trust status\r\n      saveTrustStatus(updatedStatus);\r\n      \r\n      return updatedStatus;\r\n    });\r\n  };\r\n\r\n  // Initialize device fingerprint\r\n  useEffect(() => {\r\n    const initializeFingerprint = async () => {\r\n      try {\r\n        const fp = await FingerprintJS.load();\r\n        const result = await fp.get();\r\n        const deviceId = result.visitorId;\r\n        setDeviceId(deviceId);\r\n        console.log('Device fingerprint:', deviceId);\r\n      } catch (error) {\r\n        console.error('Error initializing fingerprint:', error);\r\n        setStatus('Error initializing device fingerprint');\r\n      }\r\n    };\r\n    \r\n    initializeFingerprint();\r\n    loadKnownIdentities();\r\n    loadChatHistory();\r\n    loadTrustStatus();\r\n    checkRelayStatus();\r\n    \r\n    // Scroll to bottom when messages change\r\n    if (messagesEndRef.current) {\r\n      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });\r\n    }\r\n    \r\n    // Add window unload handler to ensure username is released when browser is closed\r\n    const handleBeforeUnload = () => {\r\n      if (socketRef.current && socketRef.current.connected && username) {\r\n        // Synchronous logout call to ensure it happens before page unload\r\n        socketRef.current.emit('userLogout', { username, deviceId });\r\n      }\r\n    };\r\n    \r\n    window.addEventListener('beforeunload', handleBeforeUnload);\r\n    \r\n    return () => {\r\n      // Clean up event listener\r\n      window.removeEventListener('beforeunload', handleBeforeUnload);\r\n      \r\n      // Logout and disconnect\r\n      if (socketRef.current && socketRef.current.connected && username) {\r\n        socketRef.current.emit('userLogout', { username, deviceId });\r\n        socketRef.current.disconnect();\r\n      }\r\n      \r\n      clearInterval(pingIntervalRef.current);\r\n      clearTimeout(recipientCheckTimeoutRef.current);\r\n      clearTimeout(typingTimeoutRef.current);\r\n    };\r\n  }, [username, deviceId]);\r\n  \r\n  // Scroll to bottom when messages change\r\n  useEffect(() => {\r\n    if (messagesEndRef.current) {\r\n      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });\r\n    }\r\n  }, [messages]);\r\n  \r\n  // Update connection info when connection details change\r\n  useEffect(() => {\r\n    if (connected && showConnectionInfo) {\r\n      // Update connection info\r\n    }\r\n  }, [connected, showConnectionInfo, username]);\r\n\r\n  const checkRelayStatus = async () => {\r\n    setRelayStatus('checking');\r\n    setStatus('Checking base node status...');\r\n    \r\n    // Try HTTP health check first\r\n    try {\r\n      const response = await axios.get(`${BASE_NODE_URL}/health`, { \r\n        timeout: 5000 \r\n      });\r\n      \r\n      if (response.status === 200) {\r\n        setRelayStatus('online');\r\n        setStatus('Base node online. Please login.');\r\n        return;\r\n      }\r\n    } catch (error) {\r\n      console.log('HTTP health check failed, trying socket connection:', error.message);\r\n    }\r\n    \r\n    // Fallback to socket connection test\r\n    const tempSocket = io(BASE_NODE_URL, {\r\n      transports: ['websocket', 'polling'],\r\n      reconnectionAttempts: 2,\r\n      reconnectionDelay: 1000,\r\n      timeout: 5000,\r\n      forceNew: true\r\n    });\r\n    \r\n    tempSocket.on('connect', () => {\r\n      console.log('Connected to base node for status check');\r\n      setRelayStatus('online');\r\n      setStatus('Base node online. Please login.');\r\n      tempSocket.disconnect();\r\n    });\r\n    \r\n    tempSocket.on('connect_error', (err) => {\r\n      console.error('Base node connection error:', err);\r\n      setRelayStatus('offline');\r\n      setStatus('Base node offline. Please try again later.');\r\n      tempSocket.disconnect();\r\n    });\r\n  };\r\n\r\n  // Main socket connection effect\r\n  useEffect(() => {\r\n    if (connected && username && deviceId) {\r\n      connectToBaseNode();\r\n    }\r\n    \r\n    return () => {\r\n      if (socketRef.current) {\r\n        clearInterval(pingIntervalRef.current);\r\n        clearTimeout(recipientCheckTimeoutRef.current);\r\n        clearTimeout(typingTimeoutRef.current);\r\n        socketRef.current.disconnect();\r\n        socketRef.current = null;\r\n      }\r\n    };\r\n  }, [connected, username, deviceId]);\r\n\r\n  const handleUsernameSubmit = async (e) => {\r\n    e.preventDefault();\r\n    \r\n    if (!username.trim() || !deviceId) {\r\n      setStatus('Please enter a valid username');\r\n      return;\r\n    }\r\n    \r\n    if (relayStatus !== 'online') {\r\n      setStatus('Cannot connect: Base node is offline');\r\n      return;\r\n    }\r\n    \r\n    try {\r\n      setStatus('Checking username availability...');\r\n      setIsCheckingUsername(true);\r\n      \r\n      // Skip username check if we're in development mode and the server is not responding\r\n      let usernameIsAvailable = true;\r\n      \r\n      try {\r\n        // Check if username is available\r\n        const response = await axios.get(`${BASE_NODE_URL}/check-username/${username}`, {\r\n          timeout: 5000\r\n        });\r\n        \r\n        usernameIsAvailable = response.data.available;\r\n      } catch (checkError) {\r\n        console.warn('Username check failed, proceeding anyway:', checkError);\r\n        // In case of error, we'll assume the username is available\r\n        // This allows development without the backend running\r\n      }\r\n      \r\n      setIsCheckingUsername(false);\r\n      \r\n      if (usernameIsAvailable) {\r\n        console.log('Username is available');\r\n        setUsernameAvailable(true);\r\n        \r\n        // Generate encryption keys if needed\r\n        if (!keyPair) {\r\n          setStatus('Generating encryption keys...');\r\n          try {\r\n            const newKeyPair = await generateKeyPair();\r\n            setKeyPair(newKeyPair);\r\n            setEncryptionStatus('ready');\r\n            console.log('Encryption keys generated successfully');\r\n          } catch (error) {\r\n            console.error('Failed to generate encryption keys:', error);\r\n            setEncryptionStatus('failed');\r\n            setSecurityAlert({\r\n              username: 'System',\r\n              message: 'Failed to generate encryption keys. Messages will not be encrypted.',\r\n              type: 'error'\r\n            });\r\n          }\r\n        }\r\n        \r\n        setConnected(true);\r\n        setStatus('Connecting to network...');\r\n      } else {\r\n        console.log('Username is already taken');\r\n        setUsernameAvailable(false);\r\n        setStatus('Username is already taken. Please choose another.');\r\n      }\r\n    } catch (error) {\r\n      console.error('Error in username submission process:', error);\r\n      setIsCheckingUsername(false);\r\n      \r\n      // Allow login anyway in case of errors\r\n      setUsernameAvailable(true);\r\n      setConnected(true);\r\n      setStatus('Connecting to network (username check bypassed)...');\r\n    }\r\n  };\r\n\r\n  const handleUsernameChange = (e) => {\r\n    const newUsername = e.target.value.trim();\r\n    setUsername(newUsername);\r\n    \r\n    // Reset availability check when username changes\r\n    setUsernameAvailable(true);\r\n    \r\n    // Check username availability after a short delay\r\n    if (newUsername.length > 2) {\r\n      setIsCheckingUsername(true);\r\n      clearTimeout(window.usernameCheckTimeout);\r\n      \r\n      window.usernameCheckTimeout = setTimeout(async () => {\r\n        try {\r\n          const response = await axios.get(`${BASE_NODE_URL}/check-username/${newUsername}`, {\r\n            timeout: 5000\r\n          });\r\n          \r\n          setIsCheckingUsername(false);\r\n          setUsernameAvailable(response.data.available);\r\n        } catch (error) {\r\n          console.warn('Error checking username availability:', error);\r\n          // In case of error, assume username is available to allow development without backend\r\n          setIsCheckingUsername(false);\r\n          setUsernameAvailable(true);\r\n        }\r\n      }, 500);\r\n    } else {\r\n      setIsCheckingUsername(false);\r\n    }\r\n  };\r\n\r\n  const handleDisconnect = () => {\r\n    if (socketRef.current) {\r\n      // Explicitly notify the server that we're logging out\r\n      socketRef.current.emit('userLogout', { username, deviceId }, (response) => {\r\n        console.log('Logout response:', response);\r\n        // Disconnect after logging out\r\n        socketRef.current.disconnect();\r\n      });\r\n      \r\n      // Set a timeout to force disconnect in case the server doesn't respond\r\n      setTimeout(() => {\r\n        if (socketRef.current && socketRef.current.connected) {\r\n          socketRef.current.disconnect();\r\n        }\r\n      }, 1000);\r\n    }\r\n    \r\n    setConnected(false);\r\n    setUsername('');\r\n    setMessages([]);\r\n    setStatus('Disconnected');\r\n    clearInterval(pingIntervalRef.current);\r\n    clearTimeout(recipientCheckTimeoutRef.current);\r\n    clearTimeout(typingTimeoutRef.current);\r\n  };\r\n\r\n  const connectToBaseNode = () => {\r\n    // Clear any previous connection\r\n    if (socketRef.current) {\r\n      // First try to logout to release the username\r\n      if (socketRef.current.connected) {\r\n        socketRef.current.emit('userLogout', { username, deviceId }, () => {\r\n          socketRef.current.disconnect();\r\n          proceedWithBaseNodeConnection();\r\n        });\r\n        \r\n        // Set a timeout in case the server doesn't respond\r\n        setTimeout(() => {\r\n          if (socketRef.current && socketRef.current.connected) {\r\n            socketRef.current.disconnect();\r\n            proceedWithBaseNodeConnection();\r\n          }\r\n        }, 1000);\r\n      } else {\r\n        socketRef.current.disconnect();\r\n        proceedWithBaseNodeConnection();\r\n      }\r\n    } else {\r\n      proceedWithBaseNodeConnection();\r\n    }\r\n    \r\n    function proceedWithBaseNodeConnection() {\r\n      // Always connect to base node first for handshake and relay discovery\r\n      console.log('Connecting to base node for initial handshake:', BASE_NODE_URL);\r\n      setStatus('Connecting to base node for handshake...');\r\n      \r\n      socketRef.current = io(BASE_NODE_URL, {\r\n        transports: ['websocket', 'polling'],\r\n        reconnectionAttempts: 3,\r\n        reconnectionDelay: 1000,\r\n        query: { \r\n          username,\r\n          deviceId,\r\n          publicKey: keyPair?.publicKey ? JSON.stringify(keyPair.publicKey) : null\r\n        },\r\n        auth: {\r\n          username,\r\n          deviceId\r\n        },\r\n        forceNew: true\r\n      });\r\n      \r\n      // Connection event handlers\r\n      socketRef.current.on('connect', () => {\r\n        console.log('Connected to base node with socket ID:', socketRef.current.id);\r\n        setStatus('Connected to base node for handshake');\r\n        setRelayStatus('online');\r\n        \r\n        // When connecting to the base node, set the relay information accordingly\r\n        setConnectionDetails({\r\n          socketId: socketRef.current.id,\r\n          transport: socketRef.current.io.engine.transport.name,\r\n          baseNodeUrl: BASE_NODE_URL,\r\n          relayId: 'base_handshake',\r\n          relayStatus: 'handshake'\r\n        });\r\n        \r\n        setRelayServerUrl('Base Node (Handshake)');\r\n        \r\n        // Register with the base node\r\n        socketRef.current.emit('registerUser', { \r\n          username, \r\n          deviceId,\r\n          publicKey: keyPair?.publicKey\r\n        }, (response) => {\r\n          console.log('Registration response:', response);\r\n          \r\n          if (response && response.success) {\r\n            setStatus('Registered successfully with base node');\r\n            \r\n            // Connect socket events\r\n            connectSocketEvents();\r\n            \r\n            // Start ping interval\r\n            startPingInterval();\r\n            \r\n            // Get available relays first\r\n            socketRef.current.emit('getAvailableRelays', {}, (response) => {\r\n              console.log('Available relays:', response);\r\n              \r\n              if (response && response.relays && response.relays.length > 0) {\r\n                // Cache relay information\r\n                localStorage.setItem('whispernetRelayCache', JSON.stringify({\r\n                  timestamp: Date.now(),\r\n                  relays: response.relays\r\n                }));\r\n                \r\n                // Connect to the first available relay\r\n                connectToRelay(response.relays);\r\n              } else {\r\n                console.log('No relays available, using base node');\r\n                setStatus('No relay servers available, using base node');\r\n                \r\n                // Update connection details for direct base node connection\r\n                setRelayServerUrl('Base Node (Fallback)');\r\n                setConnectionDetails(prev => ({\r\n                  ...prev,\r\n                  relayId: 'direct',\r\n                  relayStatus: 'direct_to_base'\r\n                }));\r\n                \r\n                // Start polling for available relays\r\n                startRelayPolling();\r\n              }\r\n            });\r\n          } else {\r\n            console.error('Registration failed:', response?.reason || 'Unknown error');\r\n            setStatus(`Registration failed: ${response?.reason || 'Unknown error'}`);\r\n          }\r\n        });\r\n      });\r\n    }\r\n    \r\n    socketRef.current.on('connect_error', (err) => {\r\n      console.error('Base node connection error:', err);\r\n      setStatus(`Connection failed: ${err.message}`);\r\n      setRelayStatus('offline');\r\n      \r\n      // Try to use cached relays if available\r\n      try {\r\n        const cachedRelayInfo = localStorage.getItem('whispernetRelayCache');\r\n        if (cachedRelayInfo) {\r\n          const relayInfo = JSON.parse(cachedRelayInfo);\r\n          const cacheAge = Date.now() - relayInfo.timestamp;\r\n          \r\n          // Use cache if it's less than 1 hour old\r\n          if (cacheAge < 3600000 && relayInfo.relays && relayInfo.relays.length > 0) {\r\n            console.log('Using cached relay information');\r\n            \r\n            // Try to connect to the first cached relay\r\n            connectToRelay(relayInfo.relays[0]);\r\n            return;\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error('Error parsing cached relay info:', error);\r\n      }\r\n    });\r\n    \r\n    socketRef.current.on('disconnect', (reason) => {\r\n      console.log('Disconnected from base node:', reason);\r\n      setStatus(`Disconnected: ${reason}`);\r\n      \r\n      // Don't auto-reconnect if user manually disconnected\r\n      if (reason !== 'io client disconnect' && connected) {\r\n        setStatus('Reconnecting...');\r\n        \r\n        // Try to reconnect after a delay\r\n        setTimeout(() => {\r\n          if (connected) {\r\n            connectToBaseNode();\r\n          }\r\n        }, 3000);\r\n      }\r\n    });\r\n  };\r\n\r\n  const connectToRelay = (relays) => {\r\n    if (!relays || !relays.length) {\r\n      console.log('No relays available to connect to');\r\n      return;\r\n    }\r\n    \r\n    // Use the first available relay\r\n    const relay = relays[0];\r\n    const relayUrl = relay.url || (relay.id && (relay.id.startsWith('http') ? relay.id : `http://${relay.id}`));\r\n    \r\n    if (!relayUrl) {\r\n      console.error('Invalid relay information');\r\n      return;\r\n    }\r\n    \r\n    console.log(`Switching to relay server: ${relayUrl}`);\r\n    setStatus(`Connecting to relay server: ${relay.id || relayUrl}...`);\r\n    \r\n    // Disconnect from base node first\r\n    if (socketRef.current) {\r\n      // Keep a reference to the old socket for cleanup\r\n      const oldSocket = socketRef.current;\r\n      \r\n      // Create new socket for relay\r\n      socketRef.current = io(relayUrl, {\r\n        transports: ['websocket', 'polling'],\r\n        reconnectionAttempts: 3,\r\n        reconnectionDelay: 2000,\r\n        query: { \r\n          username,\r\n          deviceId,\r\n          publicKey: keyPair?.publicKey ? JSON.stringify(keyPair.publicKey) : null\r\n        },\r\n        forceNew: true\r\n      });\r\n      \r\n      // Set a timeout to disconnect from base node after relay connection is established\r\n      const relayConnectionTimeout = setTimeout(() => {\r\n        if (!socketRef.current || !socketRef.current.connected) {\r\n          console.log('Relay connection timed out, staying with base node');\r\n          socketRef.current = oldSocket; // Restore old socket\r\n          setStatus('Using Base Node (relay connection failed)');\r\n          setRelayServerUrl('Base Node (Fallback)');\r\n          setConnectionDetails(prev => ({\r\n            ...prev,\r\n            relayId: 'direct',\r\n            relayStatus: 'direct_to_base'\r\n          }));\r\n          \r\n          // Start polling for available relays\r\n          startRelayPolling();\r\n        }\r\n      }, 5000);\r\n      \r\n      socketRef.current.on('connect', () => {\r\n        clearTimeout(relayConnectionTimeout);\r\n        console.log(`Connected to relay server: ${relayUrl}`);\r\n        \r\n        // Register with the relay\r\n        socketRef.current.emit('register', { \r\n          username, \r\n          deviceId,\r\n          publicKey: keyPair?.publicKey\r\n        }, (response) => {\r\n          if (response && response.success) {\r\n            console.log('Successfully registered with relay');\r\n            \r\n            // Now we can safely disconnect from the base node\r\n            oldSocket.emit('userLogout', { username, deviceId }, () => {\r\n              console.log('Logged out from base node after connecting to relay');\r\n              oldSocket.disconnect();\r\n            });\r\n            \r\n            setStatus(`Connected to relay server: ${relay.id || relayUrl}`);\r\n            setRelayServerUrl(relay.id || relayUrl);\r\n            setConnectionDetails(prev => ({\r\n              ...prev,\r\n              relayId: relay.id || relayUrl,\r\n              socketId: socketRef.current.id,\r\n              transport: socketRef.current.io.engine.transport.name,\r\n              relayStatus: 'connected_to_relay',\r\n              ip: relay.ip,\r\n              port: relay.port,\r\n              connectedUsers: relay.connectedUsers\r\n            }));\r\n            \r\n            // Set up socket event handlers\r\n            connectSocketEvents();\r\n            \r\n            // Start ping interval\r\n            startPingInterval();\r\n            \r\n            // Show connection info automatically\r\n            setShowConnectionInfo(true);\r\n            setTimeout(() => {\r\n              setShowConnectionInfo(false);\r\n            }, 5000);\r\n          } else {\r\n            console.error('Failed to register with relay:', response);\r\n            setStatus('Failed to register with relay server');\r\n            \r\n            // Disconnect from relay and stay with base node\r\n            socketRef.current.disconnect();\r\n            socketRef.current = oldSocket;\r\n            \r\n            setStatus('Using Base Node (relay registration failed)');\r\n            setRelayServerUrl('Base Node (Fallback)');\r\n            setConnectionDetails(prev => ({\r\n              ...prev,\r\n              relayId: 'direct',\r\n              relayStatus: 'direct_to_base'\r\n            }));\r\n            \r\n            // Start polling for available relays\r\n            startRelayPolling();\r\n          }\r\n        });\r\n      });\r\n      \r\n      socketRef.current.on('connect_error', (err) => {\r\n        clearTimeout(relayConnectionTimeout);\r\n        console.error(`Relay connection error: ${err.message}`);\r\n        \r\n        // Stay with base node\r\n        socketRef.current = oldSocket;\r\n        \r\n        setStatus('Using Base Node (relay connection failed)');\r\n        setRelayServerUrl('Base Node (Fallback)');\r\n        setConnectionDetails(prev => ({\r\n          ...prev,\r\n          relayId: 'direct',\r\n          relayStatus: 'direct_to_base'\r\n        }));\r\n        \r\n        // Start polling for available relays\r\n        startRelayPolling();\r\n      });\r\n      \r\n      socketRef.current.on('disconnect', (reason) => {\r\n        console.log(`Disconnected from relay: ${reason}`);\r\n        \r\n        // If we were previously connected to a relay and lost connection\r\n        if (connectionDetails.relayStatus === 'connected_to_relay') {\r\n          setStatus(`Disconnected from relay: ${reason}`);\r\n          \r\n          // Try to reconnect to base node\r\n          connectToBaseNode();\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  const startRelayPolling = () => {\r\n    // Clear any existing polling interval\r\n    if (window.relayPollingInterval) {\r\n      clearInterval(window.relayPollingInterval);\r\n    }\r\n    \r\n    // Set up polling interval\r\n    window.relayPollingInterval = setInterval(() => {\r\n      if (socketRef.current && socketRef.current.connected && \r\n          (connectionDetails.relayStatus === 'direct_to_base' || connectionDetails.relayId === 'direct')) {\r\n        console.log('Polling for available relays...');\r\n        \r\n        socketRef.current.emit('getAvailableRelays', {}, (response) => {\r\n          if (response && response.relays && response.relays.length > 0) {\r\n            console.log('Found available relays:', response.relays);\r\n            \r\n            // Cache relay information\r\n            localStorage.setItem('whispernetRelayCache', JSON.stringify({\r\n              timestamp: Date.now(),\r\n              relays: response.relays\r\n            }));\r\n            \r\n            // Connect to the first available relay\r\n            connectToRelay(response.relays);\r\n            \r\n            // Clear polling interval\r\n            clearInterval(window.relayPollingInterval);\r\n          } else {\r\n            console.log('No relays available, continuing to use base node');\r\n          }\r\n        });\r\n      }\r\n    }, 30000); // Poll every 30 seconds\r\n    \r\n    // Clean up on component unmount\r\n    return () => {\r\n      if (window.relayPollingInterval) {\r\n        clearInterval(window.relayPollingInterval);\r\n      }\r\n    };\r\n  };\r\n\r\n  const connectSocketEvents = () => {\r\n    // Message handling\r\n    socketRef.current.on('receiveMessage', async (data) => {\r\n      console.log('Received message:', data);\r\n      const { from, message, fromDeviceId, timestamp, encrypted, publicKey, bounced } = data;\r\n      \r\n      // Store sender's public key if provided\r\n      if (publicKey && from) {\r\n        console.log(`Storing public key for ${from}`);\r\n        setPublicKeys(prev => ({ ...prev, [from]: publicKey }));\r\n      }\r\n      \r\n      // Security check for device ID changes\r\n      const previousMessages = messages.filter(msg => msg.from === from);\r\n      if (previousMessages.length > 0 && previousMessages[0].fromDeviceId && \r\n          previousMessages[0].fromDeviceId !== fromDeviceId) {\r\n        setSecurityAlert({\r\n          username: from,\r\n          message: `Warning: ${from} appears to be messaging from a different device!`,\r\n          type: 'warning'\r\n        });\r\n      }\r\n      \r\n      let decryptedMessage = message;\r\n      let decryptionStatus = 'plaintext';\r\n      \r\n      // Decrypt the message if it's encrypted and we have our private key\r\n      if (encrypted && keyPair?.privateKey) {\r\n        try {\r\n          console.log('Decrypting message...');\r\n          decryptedMessage = await decryptMessage(message, keyPair.privateKey);\r\n          decryptionStatus = 'decrypted';\r\n          console.log('Message decrypted successfully');\r\n        } catch (error) {\r\n          console.error('Failed to decrypt message:', error);\r\n          decryptedMessage = '[Encrypted message - cannot decrypt]';\r\n          decryptionStatus = 'failed';\r\n          \r\n          setSecurityAlert({\r\n            username: 'System',\r\n            message: `Failed to decrypt message from ${from}. Your keys may have changed.`,\r\n            type: 'warning'\r\n          });\r\n        }\r\n      }\r\n      \r\n      // Create message object\r\n      const messageObj = { \r\n        from, \r\n        message: decryptedMessage, \r\n        fromDeviceId, \r\n        timestamp: new Date(timestamp || new Date()),\r\n        encrypted,\r\n        decryptionStatus,\r\n        bounced\r\n      };\r\n      \r\n      // Add to messages array for current view\r\n      setMessages(msgs => [...msgs, messageObj]);\r\n      \r\n      // Update chat history for this contact\r\n      updateChatHistory(from, messageObj);\r\n      \r\n      // Update trust status - mark that we received a message from this user\r\n      updateTrustStatus(from, { receivedMessage: true });\r\n    });\r\n    \r\n    // Handle public key requests\r\n    socketRef.current.on('publicKeyRequest', ({ from }, ack) => {\r\n      console.log(`Public key requested by ${from}`);\r\n      \r\n      if (keyPair && keyPair.publicKey) {\r\n        console.log(`Sending public key to ${from}`);\r\n        if (ack) ack({ success: true, publicKey: keyPair.publicKey });\r\n      } else {\r\n        console.warn('No public key available to share');\r\n        if (ack) ack({ success: false, reason: 'Public key not available' });\r\n      }\r\n    });\r\n    \r\n    // User status updates\r\n    socketRef.current.on('userStatusUpdate', (data) => {\r\n      console.log('User status update:', data);\r\n      const { username: user, online } = data;\r\n      \r\n      // If this is our current recipient, update their status\r\n      if (user === recipient) {\r\n        console.log(`Updating status for current recipient ${user} to ${online ? 'online' : 'offline'}`);\r\n        setRecipientStatus(prev => ({ \r\n          ...prev, \r\n          exists: true, // If we got a status update, the user definitely exists\r\n          online,\r\n          notRegisteredYet: false // Clear this flag since we know the user exists\r\n        }));\r\n      }\r\n      \r\n      // Update online users list\r\n      setOnlineUsers(prev => {\r\n        if (online && !prev.includes(user)) {\r\n          console.log(`Adding ${user} to online users list`);\r\n          return [...prev, user];\r\n        } else if (!online && prev.includes(user)) {\r\n          console.log(`Removing ${user} from online users list`);\r\n          return prev.filter(u => u !== user);\r\n        }\r\n        return prev;\r\n      });\r\n      \r\n      // If we have a recipient, check if they're in the online users list\r\n      if (recipient) {\r\n        checkRecipientStatus();\r\n      }\r\n    });\r\n    \r\n    // Handle bulk online users updates\r\n    socketRef.current.on('onlineUsersUpdate', (data) => {\r\n      console.log('Online users update:', data);\r\n      if (data && Array.isArray(data.users)) {\r\n        setOnlineUsers(data.users);\r\n        \r\n        // If we have a recipient, check if they're in the online users list\r\n        if (recipient) {\r\n          const isOnline = data.users.includes(recipient);\r\n          console.log(`Recipient ${recipient} is ${isOnline ? 'online' : 'offline'}`);\r\n          \r\n          setRecipientStatus(prev => ({ \r\n            ...prev, \r\n            exists: prev.exists, // Keep existing value\r\n            online: isOnline,\r\n            notRegisteredYet: false // Clear this flag since we got an update\r\n          }));\r\n        }\r\n      }\r\n    });\r\n    \r\n    // Typing indicators\r\n    socketRef.current.on('userTyping', (data) => {\r\n      const { username: typingUser } = data;\r\n      if (typingUser === recipient) {\r\n        setTyping(true);\r\n        clearTimeout(typingTimeoutRef.current);\r\n        typingTimeoutRef.current = setTimeout(() => setTyping(false), 3000);\r\n      }\r\n    });\r\n    \r\n    // Error handling\r\n    socketRef.current.on('error', (error) => {\r\n      console.error('Socket error:', error);\r\n      setSecurityAlert({\r\n        username: 'System',\r\n        message: `Connection error: ${error.message || 'Unknown error'}`,\r\n        type: 'error'\r\n      });\r\n    });\r\n    \r\n    // Request online users list\r\n    if (socketRef.current && socketRef.current.connected) {\r\n      socketRef.current.emit('getOnlineUsers', {}, (response) => {\r\n        if (response && Array.isArray(response.users)) {\r\n          console.log('Online users:', response.users);\r\n          setOnlineUsers(response.users);\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  const startPingInterval = () => {\r\n    pingIntervalRef.current = setInterval(() => {\r\n      if (socketRef.current && socketRef.current.connected) {\r\n        // Send ping to keep connection alive\r\n        socketRef.current.emit('ping', {}, (response) => {\r\n          if (response) {\r\n            console.log('Ping response:', response);\r\n          }\r\n        });\r\n        \r\n        // Request online users list\r\n        socketRef.current.emit('getOnlineUsers', {}, (response) => {\r\n          if (response && Array.isArray(response.users)) {\r\n            console.log('Online users:', response.users);\r\n            setOnlineUsers(response.users);\r\n          }\r\n        });\r\n      }\r\n    }, 30000); // Ping every 30 seconds\r\n  };\r\n\r\n  const checkRecipientStatus = () => {\r\n    if (!recipient || !socketRef.current || !socketRef.current.connected) {\r\n      return;\r\n    }\r\n    \r\n    console.log(`Checking status for recipient: ${recipient}`);\r\n    \r\n    // Check if the recipient is in the online users list\r\n    const isOnline = onlineUsers.includes(recipient);\r\n    \r\n    // Check if the user exists\r\n    socketRef.current.emit('checkUser', { username: recipient }, (response) => {\r\n      console.log('Check user response:', response);\r\n      \r\n      if (response && response.exists) {\r\n        setRecipientStatus({ \r\n          exists: true, \r\n          online: isOnline,\r\n          notRegisteredYet: false\r\n        });\r\n      } else {\r\n        setRecipientStatus({ \r\n          exists: false, \r\n          online: false,\r\n          notRegisteredYet: true\r\n        });\r\n      }\r\n    });\r\n  };\r\n\r\n  const handleRecipientChange = (e) => {\r\n    const newRecipient = e.target.value.trim();\r\n    setRecipient(newRecipient);\r\n    \r\n    if (newRecipient) {\r\n      // Use a small delay to avoid too many checks while typing\r\n      if (recipientCheckTimeoutRef.current) {\r\n        clearTimeout(recipientCheckTimeoutRef.current);\r\n      }\r\n      \r\n      recipientCheckTimeoutRef.current = setTimeout(() => {\r\n        checkRecipientStatus();\r\n      }, 500); // 500ms delay\r\n    }\r\n  };\r\n\r\n  const handleSend = async (e, bounce = false) => {\r\n    e.preventDefault();\r\n    if (!recipient || !message.trim() || !socketRef.current) return;\r\n    \r\n    try {\r\n      // Show sending indicator\r\n      setStatus('Sending message...');\r\n      \r\n      // If this is a relay/bounce message, we'll proceed regardless of recipient status\r\n      if (!bounce) {\r\n        // For direct messages, we need to check if the recipient exists and is online\r\n        const recipientOnline = recipientStatus.online;\r\n        \r\n        // If recipient is not online, suggest using relay\r\n        if (!recipientOnline) {\r\n          setSecurityAlert({\r\n            username: 'System',\r\n            message: `${recipient} is offline or not found. Use the RELAY button to send a delayed message.`,\r\n            type: 'warning'\r\n          });\r\n          setStatus('Registered successfully');\r\n          return;\r\n        }\r\n      }\r\n      \r\n      // Get recipient's public key if we don't have it and encryption is enabled\r\n      if (encryptionEnabled && !publicKeys[recipient]) {\r\n        try {\r\n          await requestPublicKey(recipient);\r\n        } catch (error) {\r\n          console.error('Failed to get public key:', error);\r\n          // Continue without encryption if we can't get the key\r\n        }\r\n      }\r\n      \r\n      let finalMessage = message.trim();\r\n      let isEncrypted = false;\r\n      \r\n      // Encrypt the message if encryption is enabled and we have the recipient's public key\r\n      if (encryptionEnabled && publicKeys[recipient]) {\r\n        try {\r\n          finalMessage = await encryptMessage(message.trim(), publicKeys[recipient]);\r\n          isEncrypted = true;\r\n          console.log('Message encrypted successfully');\r\n        } catch (error) {\r\n          console.error('Failed to encrypt message:', error);\r\n          setSecurityAlert({\r\n            username: 'System',\r\n            message: 'Failed to encrypt message. Sending as plaintext.',\r\n            type: 'warning'\r\n          });\r\n        }\r\n      }\r\n      \r\n      const messageData = {\r\n        from: username, // Add sender username\r\n        to: recipient,\r\n        message: finalMessage,\r\n        deviceId,\r\n        timestamp: new Date().toISOString(),\r\n        bounce: bounce, // Always use the bounce parameter directly\r\n        encrypted: isEncrypted,\r\n        publicKey: keyPair?.publicKey // Send our public key with the message\r\n      };\r\n      \r\n      console.log('Sending message:', { \r\n        ...messageData, \r\n        message: isEncrypted ? '[ENCRYPTED]' : finalMessage,\r\n        bounce: bounce\r\n      });\r\n      \r\n      // Add a timeout to handle cases where the server doesn't respond\r\n      const messageTimeout = setTimeout(() => {\r\n        setSecurityAlert({\r\n          username: 'System',\r\n          message: 'Message sending timed out. Server may be offline.',\r\n          type: 'error'\r\n        });\r\n        setStatus('Registered successfully');\r\n      }, 10000);\r\n      \r\n      // Use the correct event name based on whether we're connected to a relay or base node\r\n      const eventName = connectionDetails.relayStatus === 'connected_to_relay' ? 'sendMessage' : 'routeMessage';\r\n      socketRef.current.emit(eventName, messageData, (response) => {\r\n        clearTimeout(messageTimeout);\r\n        console.log('Send message response:', response);\r\n        setStatus('Registered successfully');\r\n        \r\n        if (response && (response.delivered || response.bounced)) {\r\n          // Create message object\r\n          const messageObj = { \r\n            from: username, \r\n            message: message.trim(), // Store original message for display\r\n            fromDeviceId: deviceId, \r\n            timestamp: new Date(),\r\n            status: response.delivered ? 'delivered' : 'bounced',\r\n            expiresAt: response.expiresAt,\r\n            encrypted: isEncrypted\r\n          };\r\n          \r\n          // Add message to local state (store original message for display)\r\n          setMessages(msgs => [...msgs, messageObj]);\r\n          \r\n          // Update chat history for this contact\r\n          updateChatHistory(recipient, messageObj);\r\n          \r\n          // Update trust status - mark that we sent a message to this user\r\n          updateTrustStatus(recipient, { sentMessage: true });\r\n          \r\n          setMessage('');\r\n          \r\n          // Show notification if message was bounced\r\n          if (response.bounced) {\r\n            setSecurityAlert({\r\n              username: 'System',\r\n              message: `Message to ${recipient} will be delivered when they come online (expires in 4 hours)`,\r\n              type: 'info'\r\n            });\r\n          }\r\n        } else {\r\n          const errorMsg = response?.reason || 'Message delivery failed';\r\n          \r\n          if (errorMsg.includes('not found') || errorMsg.includes('User not found')) {\r\n            if (bounce) {\r\n              // For bounced messages to non-existent users, show a special message\r\n              setSecurityAlert({\r\n                username: 'System',\r\n                message: `Message will be delivered if ${recipient} registers within 4 hours.`,\r\n                type: 'info'\r\n              });\r\n              \r\n              // Create message object\r\n              const messageObj = { \r\n                from: username, \r\n                message: message.trim(),\r\n                fromDeviceId: deviceId, \r\n                timestamp: new Date(),\r\n                status: 'bounced',\r\n                expiresAt: Date.now() + 14400000, // 4 hours\r\n                encrypted: isEncrypted\r\n              };\r\n              \r\n              // Add message to local state as bounced\r\n              setMessages(msgs => [...msgs, messageObj]);\r\n              \r\n              // Update chat history for this contact\r\n              updateChatHistory(recipient, messageObj);\r\n              \r\n              // Update trust status - mark that we sent a message to this user\r\n              updateTrustStatus(recipient, { sentMessage: true });\r\n              \r\n              setMessage('');\r\n            } else {\r\n              setSecurityAlert({\r\n                username: 'System',\r\n                message: `${recipient} not found. Use the RELAY button to send a message that will be delivered if they register.`,\r\n                type: 'warning'\r\n              });\r\n            }\r\n          } else if (errorMsg.includes('offline')) {\r\n            setSecurityAlert({\r\n              username: 'System',\r\n              message: `${recipient} is offline. Use the RELAY button to send a delayed message.`,\r\n              type: 'warning'\r\n            });\r\n          } else {\r\n            setSecurityAlert({\r\n              username: 'System',\r\n              message: `Failed to send message: ${errorMsg}`,\r\n              type: 'error'\r\n            });\r\n          }\r\n        }\r\n      });\r\n    } catch (error) {\r\n      console.error('Error sending message:', error);\r\n      setSecurityAlert({\r\n        username: 'System',\r\n        message: `Error sending message: ${error.message}`,\r\n        type: 'error'\r\n      });\r\n      setStatus('Registered successfully');\r\n    }\r\n  };\r\n  \r\n  // Request public key from a user\r\n  const requestPublicKey = async (username) => {\r\n    return new Promise((resolve, reject) => {\r\n      if (!socketRef.current) {\r\n        reject(new Error('Not connected'));\r\n        return;\r\n      }\r\n      \r\n      console.log(`Requesting public key for ${username}...`);\r\n      \r\n      // Set a timeout in case the server doesn't respond\r\n      const requestTimeout = setTimeout(() => {\r\n        console.error(`Public key request for ${username} timed out`);\r\n        reject(new Error('Request timed out'));\r\n      }, 10000);\r\n      \r\n      socketRef.current.emit('requestPublicKey', { username }, (response) => {\r\n        clearTimeout(requestTimeout);\r\n        \r\n        if (response && response.success && response.publicKey) {\r\n          console.log(`Received public key for ${username}`);\r\n          setPublicKeys(prev => ({ ...prev, [username]: response.publicKey }));\r\n          resolve(response.publicKey);\r\n        } else {\r\n          const reason = response?.reason || 'Public key not available';\r\n          console.log(`No public key available for ${username}: ${reason}`);\r\n          reject(new Error(reason));\r\n        }\r\n      });\r\n    });\r\n  };\r\n  \r\n  const handleBounce = (e) => {\r\n    if (!recipient || !message.trim()) {\r\n      return;\r\n    }\r\n    \r\n    // Show confirmation before bouncing\r\n    const confirmBounce = window.confirm(\r\n      `RELAY MESSAGE\\n\\n` +\r\n      `Your message to \"${recipient}\" will be stored on ${connectionDetails.relayStatus === 'connected_to_relay' ? 'relay' : 'base node'} servers for up to 4 hours.\\n\\n` +\r\n      `It will be delivered when ${recipient} comes online or registers with the network.\\n\\n` +\r\n      `Continue?`\r\n    );\r\n    \r\n    if (confirmBounce) {\r\n      handleSend(e, true);\r\n    }\r\n  };\r\n\r\n  const handleMessageChange = (e) => {\r\n    setMessage(e.target.value);\r\n    \r\n    // Send typing indicator\r\n    if (socketRef.current && recipient && e.target.value.length > 0) {\r\n      socketRef.current.emit('typing', { to: recipient });\r\n    }\r\n  };\r\n\r\n  const dismissAlert = () => {\r\n    setSecurityAlert(null);\r\n  };\r\n\r\n  const retryConnection = () => {\r\n    checkRelayStatus();\r\n  };\r\n\r\n  // Utility functions\r\n  const getTimestamp = () => {\r\n    const now = new Date();\r\n    return `[${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}]`;\r\n  };\r\n\r\n  const formatMessageTime = (timestamp) => {\r\n    if (!timestamp) return getTimestamp();\r\n    const date = new Date(timestamp);\r\n    return `[${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}]`;\r\n  };\r\n  \r\n  // Function to switch to a specific chat\r\n  const switchToChat = (contactUsername) => {\r\n    setActiveChat(contactUsername);\r\n    setRecipient(contactUsername || '');\r\n    \r\n    // Load messages for this contact\r\n    if (contactUsername && chatHistory[contactUsername]) {\r\n      setMessages(chatHistory[contactUsername]);\r\n    } else {\r\n      setMessages([]);\r\n    }\r\n    \r\n    // Check if we need to show trust warning\r\n    if (contactUsername && trustStatus[contactUsername]) {\r\n      setShowTrustWarning(!trustStatus[contactUsername].mutualMessaging);\r\n    } else if (contactUsername) {\r\n      setShowTrustWarning(true);\r\n    } else {\r\n      setShowTrustWarning(false);\r\n    }\r\n  };\r\n  \r\n  // Function to toggle About page\r\n  const toggleAboutPage = () => {\r\n    setShowAboutPage(!showAboutPage);\r\n  };\r\n\r\n  return (\r\n    <div style={{ \r\n      background: '#0a0e14', \r\n      minHeight: '100vh', \r\n      color: '#a2aabc', \r\n      display: 'flex',\r\n      flexDirection: 'column',\r\n      fontFamily: '\"Fira Code\", monospace'\r\n    }}>\r\n      {/* Header */}\r\n      <header style={{\r\n        background: '#171c28',\r\n        padding: '16px 24px',\r\n        borderBottom: '1px solid rgba(0, 255, 170, 0.3)',\r\n        display: 'flex',\r\n        justifyContent: 'space-between',\r\n        alignItems: 'center'\r\n      }}>\r\n        <div style={{ display: 'flex', alignItems: 'center' }}>\r\n          <h1 style={{ \r\n            margin: 0, \r\n            color: '#5ccfe6', \r\n            fontFamily: '\"Fira Code\", monospace',\r\n            letterSpacing: '1px',\r\n            fontSize: '24px'\r\n          }}>WhisperNet_</h1>\r\n          \r\n          {username && (\r\n            <span style={{ \r\n              marginLeft: '16px', \r\n              color: '#bae67e', \r\n              fontSize: '14px',\r\n              padding: '4px 8px',\r\n              background: 'rgba(186, 230, 126, 0.1)',\r\n              borderRadius: '4px'\r\n            }}>\r\n              @{username}\r\n            </span>\r\n          )}\r\n        </div>\r\n        \r\n        <div style={{ display: 'flex', alignItems: 'center' }}>\r\n          <div style={{ \r\n            fontSize: 12, \r\n            padding: '4px 8px', \r\n            borderRadius: 4, \r\n            background: relayStatus === 'online' ? '#1c4b3c' : '#4b1c1c',\r\n            color: relayStatus === 'online' ? '#5ccfe6' : '#ff8f40',\r\n            cursor: 'pointer',\r\n            marginRight: '12px'\r\n          }} onClick={() => setShowConnectionInfo(!showConnectionInfo)}>\r\n            {relayStatus === 'online' ? 'Base Node Online' : \r\n             relayStatus === 'checking' ? 'Checking...' : 'Base Node Offline'}\r\n          </div>\r\n          \r\n          {connected && (\r\n            <button \r\n              style={{ \r\n                padding: '8px 16px', \r\n                borderRadius: 4, \r\n                background: '#4b1c1c', \r\n                color: '#ff8f40', \r\n                fontSize: 14, \r\n                border: 'none',\r\n                cursor: 'pointer',\r\n                fontFamily: '\"Fira Code\", monospace',\r\n                marginRight: '12px'\r\n              }} \r\n              onClick={handleDisconnect}\r\n            >\r\n              DISCONNECT\r\n            </button>\r\n          )}\r\n          \r\n          <button \r\n            style={{ \r\n              padding: '8px 16px', \r\n              borderRadius: 4, \r\n              background: '#1c3b4b', \r\n              color: '#5ccfe6', \r\n              fontSize: 14, \r\n              border: 'none',\r\n              cursor: 'pointer',\r\n              fontFamily: '\"Fira Code\", monospace'\r\n            }} \r\n            onClick={toggleAboutPage}\r\n          >\r\n            {showAboutPage ? 'BACK TO CHAT' : 'ABOUT'}\r\n          </button>\r\n        </div>\r\n      </header>\r\n      \r\n      {/* Connection info */}\r\n      {showConnectionInfo && (\r\n        <div style={{ padding: '0 24px' }}>\r\n          <ConnectionInfo\r\n            status={status}\r\n            connected={connected}\r\n            connectionDetails={connectionDetails}\r\n            relayServerUrl={relayServerUrl}\r\n            relayStatus={relayStatus}\r\n            deviceId={deviceId}\r\n            BASE_NODE_URL={BASE_NODE_URL}\r\n          />\r\n        </div>\r\n      )}\r\n      \r\n      {/* Security alert */}\r\n      {securityAlert && (\r\n        <div style={{ padding: '0 24px' }}>\r\n          <SecurityAlert alert={securityAlert} onDismiss={dismissAlert} />\r\n        </div>\r\n      )}\r\n      \r\n      {/* Main content */}\r\n      <div style={{ \r\n        flex: 1,\r\n        display: 'flex',\r\n        height: 'calc(100vh - 69px - (showConnectionInfo ? 80 : 0) - (securityAlert ? 60 : 0))' // Subtract header height and optional elements\r\n      }}>\r\n        {showAboutPage ? (\r\n          <AboutPage />\r\n        ) : !connected ? (\r\n          <LoginScreen\r\n            username={username}\r\n            handleUsernameChange={handleUsernameChange}\r\n            handleUsernameSubmit={handleUsernameSubmit}\r\n            isCheckingUsername={isCheckingUsername}\r\n            usernameAvailable={usernameAvailable}\r\n            relayStatus={relayStatus}\r\n            status={status}\r\n            securityAlert={securityAlert}\r\n            dismissAlert={dismissAlert}\r\n            retryConnection={retryConnection}\r\n            getTimestamp={getTimestamp}\r\n          />\r\n        ) : (\r\n          <ChatInterface\r\n            contacts={contacts}\r\n            activeChat={activeChat}\r\n            switchToChat={switchToChat}\r\n            onlineUsers={onlineUsers}\r\n            trustStatus={trustStatus}\r\n            recipient={recipient}\r\n            handleRecipientChange={handleRecipientChange}\r\n            message={message}\r\n            handleMessageChange={handleMessageChange}\r\n            handleSend={handleSend}\r\n            handleBounce={handleBounce}\r\n            recipientStatus={recipientStatus}\r\n            messages={messages}\r\n            username={username}\r\n            typing={typing}\r\n            messagesEndRef={messagesEndRef}\r\n            formatMessageTime={formatMessageTime}\r\n            getTimestamp={getTimestamp}\r\n            showTrustWarning={showTrustWarning}\r\n          />\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}