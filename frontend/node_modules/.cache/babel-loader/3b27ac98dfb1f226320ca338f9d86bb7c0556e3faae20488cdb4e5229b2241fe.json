{"ast":null,"code":"// Key Verification Utilities\n// This module handles key exchange, storage, and verification for user identity\n\n/**\r\n * Stores a verified key for a user\r\n * @param {string} currentUser - The current user's username\r\n * @param {string} contactUsername - The contact's username\r\n * @param {Object} publicKey - The contact's public key in JWK format\r\n * @param {string} deviceId - The contact's device ID\r\n * @returns {boolean} - Success status\r\n */\nexport const storeVerifiedKey = (currentUser, contactUsername, publicKey, deviceId) => {\n  try {\n    // Create a unique key for the keystore\n    const keyStoreKey = `whispernetKeyStore_${currentUser}`;\n\n    // Get existing keystore or create a new one\n    let keyStore = {};\n    const existingStore = localStorage.getItem(keyStoreKey);\n    if (existingStore) {\n      keyStore = JSON.parse(existingStore);\n    }\n\n    // Store the key with device ID and verification timestamp\n    keyStore[contactUsername] = {\n      publicKey,\n      deviceId,\n      verifiedAt: Date.now(),\n      fingerprint: generateKeyFingerprint(publicKey)\n    };\n\n    // Save to localStorage\n    localStorage.setItem(keyStoreKey, JSON.stringify(keyStore));\n    return true;\n  } catch (error) {\n    console.error('Error storing verified key:', error);\n    return false;\n  }\n};\n\n/**\r\n * Retrieves a verified key for a user\r\n * @param {string} currentUser - The current user's username\r\n * @param {string} contactUsername - The contact's username\r\n * @returns {Object|null} - The stored key information or null if not found\r\n */\nexport const getVerifiedKey = (currentUser, contactUsername) => {\n  try {\n    // Create a unique key for the keystore\n    const keyStoreKey = `whispernetKeyStore_${currentUser}`;\n\n    // Get existing keystore\n    const existingStore = localStorage.getItem(keyStoreKey);\n    if (existingStore) {\n      const keyStore = JSON.parse(existingStore);\n      return keyStore[contactUsername] || null;\n    }\n    return null;\n  } catch (error) {\n    console.error('Error retrieving verified key:', error);\n    return null;\n  }\n};\n\n/**\r\n * Checks if a user has a verified key\r\n * @param {string} currentUser - The current user's username\r\n * @param {string} contactUsername - The contact's username\r\n * @returns {boolean} - Whether the user has a verified key\r\n */\nexport const hasVerifiedKey = (currentUser, contactUsername) => {\n  return getVerifiedKey(currentUser, contactUsername) !== null;\n};\n\n/**\r\n * Verifies if a received key matches the stored key\r\n * @param {string} currentUser - The current user's username\r\n * @param {string} contactUsername - The contact's username\r\n * @param {Object} receivedKey - The received public key in JWK format\r\n * @param {string} receivedDeviceId - The received device ID\r\n * @returns {Promise<Object>} - Promise resolving to verification result with status and details\r\n */\nexport const verifyKey = (currentUser, contactUsername, receivedKey, receivedDeviceId) => {\n  return new Promise((resolve, reject) => {\n    try {\n      const storedKeyInfo = getVerifiedKey(currentUser, contactUsername);\n\n      // If no stored key, this is a new contact\n      if (!storedKeyInfo) {\n        resolve({\n          verified: false,\n          status: 'new_contact',\n          message: 'New contact, no previous verification'\n        });\n        return;\n      }\n\n      // Get the stored fingerprint\n      const storedFingerprint = storedKeyInfo.fingerprint;\n\n      // Generate fingerprint for the received key\n      generateKeyFingerprint(receivedKey).then(receivedFingerprint => {\n        // Check if the key fingerprint matches\n        if (receivedFingerprint !== storedFingerprint) {\n          resolve({\n            verified: false,\n            status: 'key_mismatch',\n            message: 'Public key has changed since last verification',\n            previousDeviceId: storedKeyInfo.deviceId,\n            currentDeviceId: receivedDeviceId,\n            previousFingerprint: storedFingerprint,\n            fingerprint: receivedFingerprint\n          });\n          return;\n        }\n\n        // Check if the device ID matches\n        if (storedKeyInfo.deviceId !== receivedDeviceId) {\n          resolve({\n            verified: false,\n            status: 'device_changed',\n            message: 'Device ID has changed since last verification',\n            previousDeviceId: storedKeyInfo.deviceId,\n            currentDeviceId: receivedDeviceId,\n            fingerprint: receivedFingerprint\n          });\n          return;\n        }\n\n        // All checks passed\n        resolve({\n          verified: true,\n          status: 'verified',\n          message: 'Identity verified',\n          verifiedAt: storedKeyInfo.verifiedAt,\n          fingerprint: receivedFingerprint\n        });\n      }).catch(error => {\n        console.error('Error generating fingerprint during verification:', error);\n        reject(error);\n      });\n    } catch (error) {\n      console.error('Error verifying key:', error);\n      resolve({\n        verified: false,\n        status: 'error',\n        message: 'Error verifying key: ' + error.message\n      });\n    }\n  });\n};\n\n/**\r\n * Generates a fingerprint for a public key\r\n * @param {Object} publicKey - The public key in JWK format\r\n * @returns {Promise<string>} - Promise resolving to the fingerprint as a hex string\r\n */\nexport const generateKeyFingerprint = publicKey => {\n  return new Promise(resolve => {\n    try {\n      // Convert JWK to a stable string representation\n      const keyString = JSON.stringify(publicKey, Object.keys(publicKey).sort());\n\n      // Use SubtleCrypto to hash the key\n      const encoder = new TextEncoder();\n      const data = encoder.encode(keyString);\n      window.crypto.subtle.digest('SHA-256', data).then(hashBuffer => {\n        // Convert hash to hex string\n        const hashArray = Array.from(new Uint8Array(hashBuffer));\n        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n\n        // Return a shortened version for display (first 16 chars)\n        resolve(hashHex.substring(0, 16));\n      }).catch(error => {\n        console.error('Error generating key fingerprint with SubtleCrypto:', error);\n\n        // Fallback to a simple hash if SubtleCrypto fails\n        let hash = 0;\n        for (let i = 0; i < keyString.length; i++) {\n          const char = keyString.charCodeAt(i);\n          hash = (hash << 5) - hash + char;\n          hash = hash & hash; // Convert to 32bit integer\n        }\n        resolve(Math.abs(hash).toString(16).substring(0, 16));\n      });\n    } catch (error) {\n      console.error('Error generating key fingerprint:', error);\n\n      // Fallback to a timestamp-based fingerprint if all else fails\n      const fallbackFingerprint = Date.now().toString(16).substring(0, 16);\n      resolve(fallbackFingerprint);\n    }\n  });\n};\n\n/**\r\n * Gets all verified contacts\r\n * @param {string} currentUser - The current user's username\r\n * @returns {Array} - Array of verified contact usernames\r\n */\nexport const getVerifiedContacts = currentUser => {\n  try {\n    // Create a unique key for the keystore\n    const keyStoreKey = `whispernetKeyStore_${currentUser}`;\n\n    // Get existing keystore\n    const existingStore = localStorage.getItem(keyStoreKey);\n    if (existingStore) {\n      const keyStore = JSON.parse(existingStore);\n      return Object.keys(keyStore);\n    }\n    return [];\n  } catch (error) {\n    console.error('Error getting verified contacts:', error);\n    return [];\n  }\n};\n\n/**\r\n * Removes a verified key for a user\r\n * @param {string} currentUser - The current user's username\r\n * @param {string} contactUsername - The contact's username\r\n * @returns {boolean} - Success status\r\n */\nexport const removeVerifiedKey = (currentUser, contactUsername) => {\n  try {\n    // Create a unique key for the keystore\n    const keyStoreKey = `whispernetKeyStore_${currentUser}`;\n\n    // Get existing keystore\n    const existingStore = localStorage.getItem(keyStoreKey);\n    if (existingStore) {\n      const keyStore = JSON.parse(existingStore);\n\n      // Remove the key\n      if (keyStore[contactUsername]) {\n        delete keyStore[contactUsername];\n\n        // Save to localStorage\n        localStorage.setItem(keyStoreKey, JSON.stringify(keyStore));\n        return true;\n      }\n    }\n    return false;\n  } catch (error) {\n    console.error('Error removing verified key:', error);\n    return false;\n  }\n};\n\n/**\r\n * Clears all verified keys for a user\r\n * @param {string} currentUser - The current user's username\r\n * @returns {boolean} - Success status\r\n */\nexport const clearAllVerifiedKeys = currentUser => {\n  try {\n    // Create a unique key for the keystore\n    const keyStoreKey = `whispernetKeyStore_${currentUser}`;\n\n    // Remove from localStorage\n    localStorage.removeItem(keyStoreKey);\n    return true;\n  } catch (error) {\n    console.error('Error clearing verified keys:', error);\n    return false;\n  }\n};\n\n/**\r\n * Detects if localStorage has been reset\r\n * @returns {boolean} - Whether localStorage appears to have been reset\r\n */\nexport const detectStorageReset = () => {\n  try {\n    // Check if we have a marker in localStorage\n    const marker = localStorage.getItem('whispernetStorageMarker');\n    if (!marker) {\n      // Set a marker for future checks\n      localStorage.setItem('whispernetStorageMarker', Date.now().toString());\n\n      // Check if we have any other WhisperNet data\n      // If we do, storage was likely reset\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key.startsWith('whispernet') && key !== 'whispernetStorageMarker') {\n          return false; // We have other data, so storage wasn't reset\n        }\n      }\n\n      // No other WhisperNet data found, this might be first run\n      return false;\n    }\n\n    // Marker exists, storage wasn't reset\n    return false;\n  } catch (error) {\n    console.error('Error detecting storage reset:', error);\n    return false;\n  }\n};\n\n/**\r\n * Formats a verification timestamp\r\n * @param {number} timestamp - The verification timestamp\r\n * @returns {string} - Formatted date string\r\n */\nexport const formatVerificationTime = timestamp => {\n  if (!timestamp) return 'Unknown';\n  const date = new Date(timestamp);\n  return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {\n    hour: '2-digit',\n    minute: '2-digit'\n  });\n};","map":{"version":3,"names":["storeVerifiedKey","currentUser","contactUsername","publicKey","deviceId","keyStoreKey","keyStore","existingStore","localStorage","getItem","JSON","parse","verifiedAt","Date","now","fingerprint","generateKeyFingerprint","setItem","stringify","error","console","getVerifiedKey","hasVerifiedKey","verifyKey","receivedKey","receivedDeviceId","Promise","resolve","reject","storedKeyInfo","verified","status","message","storedFingerprint","then","receivedFingerprint","previousDeviceId","currentDeviceId","previousFingerprint","catch","keyString","Object","keys","sort","encoder","TextEncoder","data","encode","window","crypto","subtle","digest","hashBuffer","hashArray","Array","from","Uint8Array","hashHex","map","b","toString","padStart","join","substring","hash","i","length","char","charCodeAt","Math","abs","fallbackFingerprint","getVerifiedContacts","removeVerifiedKey","clearAllVerifiedKeys","removeItem","detectStorageReset","marker","key","startsWith","formatVerificationTime","timestamp","date","toLocaleDateString","toLocaleTimeString","hour","minute"],"sources":["C:/Users/siddharth/Documents/GitHub/WhisperNet/frontend/src/utils/keyVerification.js"],"sourcesContent":["// Key Verification Utilities\r\n// This module handles key exchange, storage, and verification for user identity\r\n\r\n/**\r\n * Stores a verified key for a user\r\n * @param {string} currentUser - The current user's username\r\n * @param {string} contactUsername - The contact's username\r\n * @param {Object} publicKey - The contact's public key in JWK format\r\n * @param {string} deviceId - The contact's device ID\r\n * @returns {boolean} - Success status\r\n */\r\nexport const storeVerifiedKey = (currentUser, contactUsername, publicKey, deviceId) => {\r\n  try {\r\n    // Create a unique key for the keystore\r\n    const keyStoreKey = `whispernetKeyStore_${currentUser}`;\r\n    \r\n    // Get existing keystore or create a new one\r\n    let keyStore = {};\r\n    const existingStore = localStorage.getItem(keyStoreKey);\r\n    \r\n    if (existingStore) {\r\n      keyStore = JSON.parse(existingStore);\r\n    }\r\n    \r\n    // Store the key with device ID and verification timestamp\r\n    keyStore[contactUsername] = {\r\n      publicKey,\r\n      deviceId,\r\n      verifiedAt: Date.now(),\r\n      fingerprint: generateKeyFingerprint(publicKey)\r\n    };\r\n    \r\n    // Save to localStorage\r\n    localStorage.setItem(keyStoreKey, JSON.stringify(keyStore));\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error storing verified key:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Retrieves a verified key for a user\r\n * @param {string} currentUser - The current user's username\r\n * @param {string} contactUsername - The contact's username\r\n * @returns {Object|null} - The stored key information or null if not found\r\n */\r\nexport const getVerifiedKey = (currentUser, contactUsername) => {\r\n  try {\r\n    // Create a unique key for the keystore\r\n    const keyStoreKey = `whispernetKeyStore_${currentUser}`;\r\n    \r\n    // Get existing keystore\r\n    const existingStore = localStorage.getItem(keyStoreKey);\r\n    \r\n    if (existingStore) {\r\n      const keyStore = JSON.parse(existingStore);\r\n      return keyStore[contactUsername] || null;\r\n    }\r\n    \r\n    return null;\r\n  } catch (error) {\r\n    console.error('Error retrieving verified key:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Checks if a user has a verified key\r\n * @param {string} currentUser - The current user's username\r\n * @param {string} contactUsername - The contact's username\r\n * @returns {boolean} - Whether the user has a verified key\r\n */\r\nexport const hasVerifiedKey = (currentUser, contactUsername) => {\r\n  return getVerifiedKey(currentUser, contactUsername) !== null;\r\n};\r\n\r\n/**\r\n * Verifies if a received key matches the stored key\r\n * @param {string} currentUser - The current user's username\r\n * @param {string} contactUsername - The contact's username\r\n * @param {Object} receivedKey - The received public key in JWK format\r\n * @param {string} receivedDeviceId - The received device ID\r\n * @returns {Promise<Object>} - Promise resolving to verification result with status and details\r\n */\r\nexport const verifyKey = (currentUser, contactUsername, receivedKey, receivedDeviceId) => {\r\n  return new Promise((resolve, reject) => {\r\n    try {\r\n      const storedKeyInfo = getVerifiedKey(currentUser, contactUsername);\r\n      \r\n      // If no stored key, this is a new contact\r\n      if (!storedKeyInfo) {\r\n        resolve({\r\n          verified: false,\r\n          status: 'new_contact',\r\n          message: 'New contact, no previous verification'\r\n        });\r\n        return;\r\n      }\r\n      \r\n      // Get the stored fingerprint\r\n      const storedFingerprint = storedKeyInfo.fingerprint;\r\n      \r\n      // Generate fingerprint for the received key\r\n      generateKeyFingerprint(receivedKey)\r\n        .then(receivedFingerprint => {\r\n          // Check if the key fingerprint matches\r\n          if (receivedFingerprint !== storedFingerprint) {\r\n            resolve({\r\n              verified: false,\r\n              status: 'key_mismatch',\r\n              message: 'Public key has changed since last verification',\r\n              previousDeviceId: storedKeyInfo.deviceId,\r\n              currentDeviceId: receivedDeviceId,\r\n              previousFingerprint: storedFingerprint,\r\n              fingerprint: receivedFingerprint\r\n            });\r\n            return;\r\n          }\r\n          \r\n          // Check if the device ID matches\r\n          if (storedKeyInfo.deviceId !== receivedDeviceId) {\r\n            resolve({\r\n              verified: false,\r\n              status: 'device_changed',\r\n              message: 'Device ID has changed since last verification',\r\n              previousDeviceId: storedKeyInfo.deviceId,\r\n              currentDeviceId: receivedDeviceId,\r\n              fingerprint: receivedFingerprint\r\n            });\r\n            return;\r\n          }\r\n          \r\n          // All checks passed\r\n          resolve({\r\n            verified: true,\r\n            status: 'verified',\r\n            message: 'Identity verified',\r\n            verifiedAt: storedKeyInfo.verifiedAt,\r\n            fingerprint: receivedFingerprint\r\n          });\r\n        })\r\n        .catch(error => {\r\n          console.error('Error generating fingerprint during verification:', error);\r\n          reject(error);\r\n        });\r\n    } catch (error) {\r\n      console.error('Error verifying key:', error);\r\n      resolve({\r\n        verified: false,\r\n        status: 'error',\r\n        message: 'Error verifying key: ' + error.message\r\n      });\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Generates a fingerprint for a public key\r\n * @param {Object} publicKey - The public key in JWK format\r\n * @returns {Promise<string>} - Promise resolving to the fingerprint as a hex string\r\n */\r\nexport const generateKeyFingerprint = (publicKey) => {\r\n  return new Promise((resolve) => {\r\n    try {\r\n      // Convert JWK to a stable string representation\r\n      const keyString = JSON.stringify(publicKey, Object.keys(publicKey).sort());\r\n      \r\n      // Use SubtleCrypto to hash the key\r\n      const encoder = new TextEncoder();\r\n      const data = encoder.encode(keyString);\r\n      \r\n      window.crypto.subtle.digest('SHA-256', data)\r\n        .then(hashBuffer => {\r\n          // Convert hash to hex string\r\n          const hashArray = Array.from(new Uint8Array(hashBuffer));\r\n          const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\r\n          \r\n          // Return a shortened version for display (first 16 chars)\r\n          resolve(hashHex.substring(0, 16));\r\n        })\r\n        .catch(error => {\r\n          console.error('Error generating key fingerprint with SubtleCrypto:', error);\r\n          \r\n          // Fallback to a simple hash if SubtleCrypto fails\r\n          let hash = 0;\r\n          for (let i = 0; i < keyString.length; i++) {\r\n            const char = keyString.charCodeAt(i);\r\n            hash = ((hash << 5) - hash) + char;\r\n            hash = hash & hash; // Convert to 32bit integer\r\n          }\r\n          resolve(Math.abs(hash).toString(16).substring(0, 16));\r\n        });\r\n    } catch (error) {\r\n      console.error('Error generating key fingerprint:', error);\r\n      \r\n      // Fallback to a timestamp-based fingerprint if all else fails\r\n      const fallbackFingerprint = Date.now().toString(16).substring(0, 16);\r\n      resolve(fallbackFingerprint);\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Gets all verified contacts\r\n * @param {string} currentUser - The current user's username\r\n * @returns {Array} - Array of verified contact usernames\r\n */\r\nexport const getVerifiedContacts = (currentUser) => {\r\n  try {\r\n    // Create a unique key for the keystore\r\n    const keyStoreKey = `whispernetKeyStore_${currentUser}`;\r\n    \r\n    // Get existing keystore\r\n    const existingStore = localStorage.getItem(keyStoreKey);\r\n    \r\n    if (existingStore) {\r\n      const keyStore = JSON.parse(existingStore);\r\n      return Object.keys(keyStore);\r\n    }\r\n    \r\n    return [];\r\n  } catch (error) {\r\n    console.error('Error getting verified contacts:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n/**\r\n * Removes a verified key for a user\r\n * @param {string} currentUser - The current user's username\r\n * @param {string} contactUsername - The contact's username\r\n * @returns {boolean} - Success status\r\n */\r\nexport const removeVerifiedKey = (currentUser, contactUsername) => {\r\n  try {\r\n    // Create a unique key for the keystore\r\n    const keyStoreKey = `whispernetKeyStore_${currentUser}`;\r\n    \r\n    // Get existing keystore\r\n    const existingStore = localStorage.getItem(keyStoreKey);\r\n    \r\n    if (existingStore) {\r\n      const keyStore = JSON.parse(existingStore);\r\n      \r\n      // Remove the key\r\n      if (keyStore[contactUsername]) {\r\n        delete keyStore[contactUsername];\r\n        \r\n        // Save to localStorage\r\n        localStorage.setItem(keyStoreKey, JSON.stringify(keyStore));\r\n        return true;\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  } catch (error) {\r\n    console.error('Error removing verified key:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Clears all verified keys for a user\r\n * @param {string} currentUser - The current user's username\r\n * @returns {boolean} - Success status\r\n */\r\nexport const clearAllVerifiedKeys = (currentUser) => {\r\n  try {\r\n    // Create a unique key for the keystore\r\n    const keyStoreKey = `whispernetKeyStore_${currentUser}`;\r\n    \r\n    // Remove from localStorage\r\n    localStorage.removeItem(keyStoreKey);\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error clearing verified keys:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Detects if localStorage has been reset\r\n * @returns {boolean} - Whether localStorage appears to have been reset\r\n */\r\nexport const detectStorageReset = () => {\r\n  try {\r\n    // Check if we have a marker in localStorage\r\n    const marker = localStorage.getItem('whispernetStorageMarker');\r\n    \r\n    if (!marker) {\r\n      // Set a marker for future checks\r\n      localStorage.setItem('whispernetStorageMarker', Date.now().toString());\r\n      \r\n      // Check if we have any other WhisperNet data\r\n      // If we do, storage was likely reset\r\n      for (let i = 0; i < localStorage.length; i++) {\r\n        const key = localStorage.key(i);\r\n        if (key.startsWith('whispernet') && key !== 'whispernetStorageMarker') {\r\n          return false; // We have other data, so storage wasn't reset\r\n        }\r\n      }\r\n      \r\n      // No other WhisperNet data found, this might be first run\r\n      return false;\r\n    }\r\n    \r\n    // Marker exists, storage wasn't reset\r\n    return false;\r\n  } catch (error) {\r\n    console.error('Error detecting storage reset:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Formats a verification timestamp\r\n * @param {number} timestamp - The verification timestamp\r\n * @returns {string} - Formatted date string\r\n */\r\nexport const formatVerificationTime = (timestamp) => {\r\n  if (!timestamp) return 'Unknown';\r\n  \r\n  const date = new Date(timestamp);\r\n  return date.toLocaleDateString() + ' ' + \r\n    date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}