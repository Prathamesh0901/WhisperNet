{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\siddharth\\\\Documents\\\\GitHub\\\\WhisperNet\\\\frontend\\\\src\\\\App.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useEffect } from 'react';\nimport io from 'socket.io-client';\nimport axios from 'axios';\nimport FingerprintJS from '@fingerprintjs/fingerprintjs';\n\n// Import components\nimport ConnectionInfo from './components/ConnectionInfo';\nimport SecurityAlert from './components/SecurityAlert';\nimport LoginScreen from './components/LoginScreen';\nimport ChatInterface from './components/ChatInterface';\nimport AboutPage from './components/AboutPage';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst BASE_NODE_URL = process.env.REACT_APP_BASE_NODE_URL || \"http://localhost:5000\";\n\n// Storage keys\nconst IDENTITY_STORAGE_KEY = 'whispernetKnownIdentities';\nconst CHAT_HISTORY_KEY = 'whispernetChatHistory';\nconst TRUST_STATUS_KEY = 'whispernetTrustStatus';\n\n// Encryption utilities\nconst generateKeyPair = async () => {\n  try {\n    const keyPair = await window.crypto.subtle.generateKey({\n      name: \"RSA-OAEP\",\n      modulusLength: 2048,\n      publicExponent: new Uint8Array([1, 0, 1]),\n      hash: \"SHA-256\"\n    }, true, [\"encrypt\", \"decrypt\"]);\n\n    // Export the keys to JWK format\n    const publicKey = await window.crypto.subtle.exportKey(\"jwk\", keyPair.publicKey);\n    const privateKey = await window.crypto.subtle.exportKey(\"jwk\", keyPair.privateKey);\n    return {\n      publicKey,\n      privateKey\n    };\n  } catch (error) {\n    console.error('Error generating key pair:', error);\n    throw error;\n  }\n};\nconst encryptMessage = async (message, publicKeyJwk) => {\n  try {\n    // Import the public key\n    const publicKey = await window.crypto.subtle.importKey(\"jwk\", publicKeyJwk, {\n      name: \"RSA-OAEP\",\n      hash: \"SHA-256\"\n    }, false, [\"encrypt\"]);\n\n    // Convert the message to an ArrayBuffer\n    const encoder = new TextEncoder();\n    const data = encoder.encode(message);\n\n    // Encrypt the data\n    const encryptedData = await window.crypto.subtle.encrypt({\n      name: \"RSA-OAEP\"\n    }, publicKey, data);\n\n    // Convert the encrypted data to a base64 string\n    return btoa(String.fromCharCode(...new Uint8Array(encryptedData)));\n  } catch (error) {\n    console.error('Error encrypting message:', error);\n    throw error;\n  }\n};\nconst decryptMessage = async (encryptedMessage, privateKeyJwk) => {\n  try {\n    // Import the private key\n    const privateKey = await window.crypto.subtle.importKey(\"jwk\", privateKeyJwk, {\n      name: \"RSA-OAEP\",\n      hash: \"SHA-256\"\n    }, false, [\"decrypt\"]);\n\n    // Convert the base64 string to an ArrayBuffer\n    const encryptedData = new Uint8Array(atob(encryptedMessage).split('').map(char => char.charCodeAt(0)));\n\n    // Decrypt the data\n    const decryptedData = await window.crypto.subtle.decrypt({\n      name: \"RSA-OAEP\"\n    }, privateKey, encryptedData);\n\n    // Convert the decrypted data to a string\n    const decoder = new TextDecoder();\n    return decoder.decode(decryptedData);\n  } catch (error) {\n    console.error('Error decrypting message:', error);\n    throw error;\n  }\n};\nfunction App() {\n  _s();\n  // Connection state\n  const [connected, setConnected] = useState(false);\n  const [username, setUsername] = useState('');\n  const [deviceId, setDeviceId] = useState('');\n  const [status, setStatus] = useState('Initializing...');\n  const [relayStatus, setRelayStatus] = useState('checking');\n  const [relayServerUrl, setRelayServerUrl] = useState('');\n  const [connectionDetails, setConnectionDetails] = useState({});\n  const [showConnectionInfo, setShowConnectionInfo] = useState(false);\n  const [securityAlert, setSecurityAlert] = useState(null);\n\n  // Message state\n  const [recipient, setRecipient] = useState('');\n  const [message, setMessage] = useState('');\n  const [messages, setMessages] = useState([]);\n  const [typing, setTyping] = useState(false);\n  const [onlineUsers, setOnlineUsers] = useState([]);\n  const [recipientStatus, setRecipientStatus] = useState({\n    exists: false,\n    online: false\n  });\n  const [isCheckingUsername, setIsCheckingUsername] = useState(false);\n  const [usernameAvailable, setUsernameAvailable] = useState(true);\n\n  // Encryption state\n  const [keyPair, setKeyPair] = useState(null);\n  const [publicKeys, setPublicKeys] = useState({});\n  const [encryptionEnabled, setEncryptionEnabled] = useState(true);\n  const [encryptionStatus, setEncryptionStatus] = useState('initializing');\n  const [knownIdentities, setKnownIdentities] = useState({}); // username -> {deviceId, publicKey, firstSeen}\n  const [identityMismatch, setIdentityMismatch] = useState(null); // {username, originalDeviceId, newDeviceId, action}\n  const [showIdentityWarning, setShowIdentityWarning] = useState(false);\n\n  // New state variables for enhanced chat functionality\n  const [chatHistory, setChatHistory] = useState({}); // username -> array of messages\n  const [contacts, setContacts] = useState([]); // list of usernames the current user has chatted with\n  const [activeChat, setActiveChat] = useState(null); // currently selected chat\n  const [trustStatus, setTrustStatus] = useState({}); // username -> {trusted: boolean, keyExchanged: boolean, mutualMessaging: boolean}\n  const [showTrustWarning, setShowTrustWarning] = useState(false); // whether to show the trust warning for the current chat\n\n  // UI state variables\n  const [showAboutPage, setShowAboutPage] = useState(false); // whether to show the About page\n\n  const socketRef = useRef(null);\n  const messagesEndRef = useRef(null);\n  const typingTimeoutRef = useRef(null);\n  const pingIntervalRef = useRef(null);\n  const recipientCheckTimeoutRef = useRef(null);\n\n  // Load known identities from localStorage\n  const loadKnownIdentities = () => {\n    try {\n      const storedIdentities = localStorage.getItem(IDENTITY_STORAGE_KEY);\n      if (storedIdentities) {\n        setKnownIdentities(JSON.parse(storedIdentities));\n      }\n    } catch (error) {\n      console.error('Error loading known identities:', error);\n    }\n  };\n\n  // Save known identities to localStorage\n  const saveKnownIdentities = identities => {\n    try {\n      localStorage.setItem(IDENTITY_STORAGE_KEY, JSON.stringify(identities));\n    } catch (error) {\n      console.error('Error saving known identities:', error);\n    }\n  };\n\n  // Load chat history from localStorage\n  const loadChatHistory = () => {\n    try {\n      const storedChatHistory = localStorage.getItem(CHAT_HISTORY_KEY);\n      if (storedChatHistory) {\n        const parsedChatHistory = JSON.parse(storedChatHistory);\n        setChatHistory(parsedChatHistory);\n\n        // Extract contacts from chat history\n        const contactsList = Object.keys(parsedChatHistory);\n        setContacts(contactsList);\n        console.log('Loaded chat history for contacts:', contactsList.length);\n\n        // If we have contacts but no active chat, set the first contact as active\n        if (contactsList.length > 0 && !activeChat) {\n          setActiveChat(contactsList[0]);\n          setRecipient(contactsList[0]);\n        }\n      }\n    } catch (error) {\n      console.error('Error loading chat history:', error);\n    }\n  };\n\n  // Save chat history to localStorage\n  const saveChatHistory = history => {\n    try {\n      localStorage.setItem(CHAT_HISTORY_KEY, JSON.stringify(history));\n    } catch (error) {\n      console.error('Error saving chat history:', error);\n    }\n  };\n\n  // Load trust status from localStorage\n  const loadTrustStatus = () => {\n    try {\n      const storedTrustStatus = localStorage.getItem(TRUST_STATUS_KEY);\n      if (storedTrustStatus) {\n        setTrustStatus(JSON.parse(storedTrustStatus));\n      }\n    } catch (error) {\n      console.error('Error loading trust status:', error);\n    }\n  };\n\n  // Save trust status to localStorage\n  const saveTrustStatus = status => {\n    try {\n      localStorage.setItem(TRUST_STATUS_KEY, JSON.stringify(status));\n    } catch (error) {\n      console.error('Error saving trust status:', error);\n    }\n  };\n\n  // Update chat history for a specific contact\n  const updateChatHistory = (contact, message) => {\n    setChatHistory(prevHistory => {\n      const updatedHistory = {\n        ...prevHistory\n      };\n\n      // Initialize chat history for this contact if it doesn't exist\n      if (!updatedHistory[contact]) {\n        updatedHistory[contact] = [];\n      }\n\n      // Add the message to the chat history\n      updatedHistory[contact] = [...updatedHistory[contact], message];\n\n      // Save the updated chat history\n      saveChatHistory(updatedHistory);\n\n      // Update contacts list if this is a new contact\n      if (!contacts.includes(contact)) {\n        const updatedContacts = [...contacts, contact];\n        setContacts(updatedContacts);\n      }\n      return updatedHistory;\n    });\n  };\n\n  // Check and update trust status for a contact\n  const updateTrustStatus = (contact, updates) => {\n    setTrustStatus(prevStatus => {\n      const updatedStatus = {\n        ...prevStatus\n      };\n\n      // Initialize trust status for this contact if it doesn't exist\n      if (!updatedStatus[contact]) {\n        updatedStatus[contact] = {\n          trusted: false,\n          keyExchanged: false,\n          mutualMessaging: false,\n          sentMessage: false,\n          receivedMessage: false,\n          firstInteraction: new Date().toISOString()\n        };\n      }\n\n      // Apply updates\n      updatedStatus[contact] = {\n        ...updatedStatus[contact],\n        ...updates\n      };\n\n      // Check if mutual messaging has occurred\n      if (updatedStatus[contact].sentMessage && updatedStatus[contact].receivedMessage) {\n        updatedStatus[contact].mutualMessaging = true;\n\n        // If mutual messaging has occurred and we have their public key, mark as trusted and exchange keys\n        if (publicKeys[contact]) {\n          updatedStatus[contact].keyExchanged = true;\n          updatedStatus[contact].trusted = true;\n\n          // Update the UI to show trust status change\n          if (contact === recipient) {\n            setShowTrustWarning(false);\n          }\n        }\n      } else {\n        // If we don't have mutual messaging yet, make sure to show the warning\n        if (contact === recipient) {\n          setShowTrustWarning(true);\n        }\n      }\n\n      // Save the updated trust status\n      saveTrustStatus(updatedStatus);\n      return updatedStatus;\n    });\n  };\n\n  // Initialize device fingerprint\n  useEffect(() => {\n    const initializeFingerprint = async () => {\n      try {\n        const fp = await FingerprintJS.load();\n        const result = await fp.get();\n        const deviceId = result.visitorId;\n        setDeviceId(deviceId);\n        console.log('Device fingerprint:', deviceId);\n      } catch (error) {\n        console.error('Error initializing fingerprint:', error);\n        setStatus('Error initializing device fingerprint');\n      }\n    };\n    initializeFingerprint();\n    loadKnownIdentities();\n    loadChatHistory();\n    loadTrustStatus();\n    checkRelayStatus();\n\n    // Scroll to bottom when messages change\n    if (messagesEndRef.current) {\n      messagesEndRef.current.scrollIntoView({\n        behavior: 'smooth'\n      });\n    }\n    return () => {\n      if (socketRef.current) {\n        socketRef.current.disconnect();\n      }\n      clearInterval(pingIntervalRef.current);\n      clearTimeout(recipientCheckTimeoutRef.current);\n      clearTimeout(typingTimeoutRef.current);\n    };\n  }, []);\n\n  // Scroll to bottom when messages change\n  useEffect(() => {\n    if (messagesEndRef.current) {\n      messagesEndRef.current.scrollIntoView({\n        behavior: 'smooth'\n      });\n    }\n  }, [messages]);\n\n  // Update connection info when connection details change\n  useEffect(() => {\n    if (connected && showConnectionInfo) {\n      // Update connection info\n    }\n  }, [connected, showConnectionInfo, username]);\n  const checkRelayStatus = async () => {\n    setRelayStatus('checking');\n    setStatus('Checking base node status...');\n\n    // Try HTTP health check first\n    try {\n      const response = await axios.get(`${BASE_NODE_URL}/health`, {\n        timeout: 5000\n      });\n      if (response.status === 200) {\n        setRelayStatus('online');\n        setStatus('Base node online. Please login.');\n        return;\n      }\n    } catch (error) {\n      console.log('HTTP health check failed, trying socket connection:', error.message);\n    }\n\n    // Fallback to socket connection test\n    const tempSocket = io(BASE_NODE_URL, {\n      transports: ['websocket', 'polling'],\n      reconnectionAttempts: 2,\n      reconnectionDelay: 1000,\n      timeout: 5000,\n      forceNew: true\n    });\n    tempSocket.on('connect', () => {\n      console.log('Connected to base node for status check');\n      setRelayStatus('online');\n      setStatus('Base node online. Please login.');\n      tempSocket.disconnect();\n    });\n    tempSocket.on('connect_error', err => {\n      console.error('Base node connection error:', err);\n      setRelayStatus('offline');\n      setStatus('Base node offline. Please try again later.');\n      tempSocket.disconnect();\n    });\n  };\n\n  // Main socket connection effect\n  useEffect(() => {\n    if (connected && username && deviceId) {\n      connectToBaseNode();\n    }\n    return () => {\n      if (socketRef.current) {\n        clearInterval(pingIntervalRef.current);\n        clearTimeout(recipientCheckTimeoutRef.current);\n        clearTimeout(typingTimeoutRef.current);\n        socketRef.current.disconnect();\n        socketRef.current = null;\n      }\n    };\n  }, [connected, username, deviceId]);\n  const handleUsernameSubmit = async e => {\n    e.preventDefault();\n    if (!username.trim() || !deviceId) {\n      setStatus('Please enter a valid username');\n      return;\n    }\n    if (relayStatus !== 'online') {\n      setStatus('Cannot connect: Base node is offline');\n      return;\n    }\n    try {\n      setStatus('Checking username availability...');\n      setIsCheckingUsername(true);\n\n      // Check if username is available\n      const response = await axios.get(`${BASE_NODE_URL}/check-username/${username}`, {\n        timeout: 5000\n      });\n      setIsCheckingUsername(false);\n      if (response.data.available) {\n        console.log('Username is available');\n        setUsernameAvailable(true);\n\n        // Generate encryption keys if needed\n        if (!keyPair) {\n          setStatus('Generating encryption keys...');\n          try {\n            const newKeyPair = await generateKeyPair();\n            setKeyPair(newKeyPair);\n            setEncryptionStatus('ready');\n            console.log('Encryption keys generated successfully');\n          } catch (error) {\n            console.error('Failed to generate encryption keys:', error);\n            setEncryptionStatus('failed');\n            setSecurityAlert({\n              username: 'System',\n              message: 'Failed to generate encryption keys. Messages will not be encrypted.',\n              type: 'error'\n            });\n          }\n        }\n        setConnected(true);\n        setStatus('Connecting to network...');\n      } else {\n        console.log('Username is already taken');\n        setUsernameAvailable(false);\n        setStatus('Username is already taken. Please choose another.');\n      }\n    } catch (error) {\n      console.error('Error checking username:', error);\n      setIsCheckingUsername(false);\n      setStatus('Error checking username. Please try again.');\n    }\n  };\n  const handleUsernameChange = e => {\n    const newUsername = e.target.value.trim();\n    setUsername(newUsername);\n\n    // Reset availability check when username changes\n    setUsernameAvailable(true);\n\n    // Check username availability after a short delay\n    if (newUsername.length > 2) {\n      setIsCheckingUsername(true);\n      clearTimeout(window.usernameCheckTimeout);\n      window.usernameCheckTimeout = setTimeout(async () => {\n        try {\n          const response = await axios.get(`${BASE_NODE_URL}/check-username/${newUsername}`, {\n            timeout: 5000\n          });\n          setIsCheckingUsername(false);\n          setUsernameAvailable(response.data.available);\n        } catch (error) {\n          console.error('Error checking username:', error);\n          setIsCheckingUsername(false);\n        }\n      }, 500);\n    } else {\n      setIsCheckingUsername(false);\n    }\n  };\n  const handleDisconnect = () => {\n    if (socketRef.current) {\n      socketRef.current.disconnect();\n    }\n    setConnected(false);\n    setUsername('');\n    setMessages([]);\n    setStatus('Disconnected');\n    clearInterval(pingIntervalRef.current);\n    clearTimeout(recipientCheckTimeoutRef.current);\n    clearTimeout(typingTimeoutRef.current);\n  };\n  const connectToBaseNode = () => {\n    // Clear any previous connection\n    if (socketRef.current) {\n      socketRef.current.disconnect();\n    }\n\n    // Always connect to base node first for handshake and relay discovery\n    console.log('Connecting to base node for initial handshake:', BASE_NODE_URL);\n    setStatus('Connecting to base node for handshake...');\n    socketRef.current = io(BASE_NODE_URL, {\n      transports: ['websocket', 'polling'],\n      reconnectionAttempts: 3,\n      reconnectionDelay: 1000,\n      query: {\n        username,\n        deviceId,\n        publicKey: keyPair !== null && keyPair !== void 0 && keyPair.publicKey ? JSON.stringify(keyPair.publicKey) : null\n      },\n      auth: {\n        username,\n        deviceId\n      },\n      forceNew: true\n    });\n\n    // Connection event handlers\n    socketRef.current.on('connect', () => {\n      console.log('Connected to base node with socket ID:', socketRef.current.id);\n      setStatus('Connected to base node for handshake');\n      setRelayStatus('online');\n\n      // When connecting to the base node, set the relay information accordingly\n      setConnectionDetails({\n        socketId: socketRef.current.id,\n        transport: socketRef.current.io.engine.transport.name,\n        baseNodeUrl: BASE_NODE_URL,\n        relayStatus: 'direct_to_base'\n      });\n      setRelayServerUrl('Base Node');\n\n      // Register with the base node\n      socketRef.current.emit('register', {\n        username,\n        deviceId,\n        publicKey: keyPair === null || keyPair === void 0 ? void 0 : keyPair.publicKey\n      }, response => {\n        console.log('Registration response:', response);\n        if (response && response.success) {\n          setStatus('Registered successfully');\n\n          // Connect socket events\n          connectSocketEvents();\n\n          // Start ping interval\n          startPingInterval();\n\n          // Get available relays first\n          socketRef.current.emit('getAvailableRelays', {}, response => {\n            console.log('Available relays:', response);\n            if (response && response.relays && response.relays.length > 0) {\n              // Cache relay information\n              localStorage.setItem('whispernetRelayCache', JSON.stringify({\n                timestamp: Date.now(),\n                relays: response.relays\n              }));\n\n              // Connect to the first available relay\n              connectToRelay(response.relays[0]);\n            } else {\n              console.log('No relays available, using base node');\n              setStatus('No relay servers available, using base node');\n\n              // Start polling for available relays\n              startRelayPolling();\n            }\n          });\n        } else {\n          console.error('Registration failed:', (response === null || response === void 0 ? void 0 : response.reason) || 'Unknown error');\n          setStatus(`Registration failed: ${(response === null || response === void 0 ? void 0 : response.reason) || 'Unknown error'}`);\n        }\n      });\n    });\n    socketRef.current.on('connect_error', err => {\n      console.error('Base node connection error:', err);\n      setStatus(`Connection failed: ${err.message}`);\n      setRelayStatus('offline');\n\n      // Try to use cached relays if available\n      try {\n        const cachedRelayInfo = localStorage.getItem('whispernetRelayCache');\n        if (cachedRelayInfo) {\n          const relayInfo = JSON.parse(cachedRelayInfo);\n          const cacheAge = Date.now() - relayInfo.timestamp;\n\n          // Use cache if it's less than 1 hour old\n          if (cacheAge < 3600000 && relayInfo.relays && relayInfo.relays.length > 0) {\n            console.log('Using cached relay information');\n\n            // Try to connect to the first cached relay\n            connectToRelay(relayInfo.relays[0]);\n            return;\n          }\n        }\n      } catch (error) {\n        console.error('Error parsing cached relay info:', error);\n      }\n    });\n    socketRef.current.on('disconnect', reason => {\n      console.log('Disconnected from base node:', reason);\n      setStatus(`Disconnected: ${reason}`);\n\n      // Don't auto-reconnect if user manually disconnected\n      if (reason !== 'io client disconnect' && connected) {\n        setStatus('Reconnecting...');\n\n        // Try to reconnect after a delay\n        setTimeout(() => {\n          if (connected) {\n            connectToBaseNode();\n          }\n        }, 3000);\n      }\n    });\n  };\n  const connectToRelay = relayInfo => {\n    if (!relayInfo || !relayInfo.url) {\n      console.error('Invalid relay information');\n      return;\n    }\n    const relayUrl = relayInfo.url;\n    console.log(`Connecting to relay server: ${relayUrl}`);\n    setStatus(`Connecting to relay server: ${relayUrl}`);\n\n    // Keep a reference to the old socket\n    const oldSocket = socketRef.current;\n\n    // Connect to the relay server\n    socketRef.current = io(relayUrl, {\n      transports: ['websocket', 'polling'],\n      reconnectionAttempts: 3,\n      reconnectionDelay: 1000,\n      query: {\n        username,\n        deviceId,\n        publicKey: keyPair !== null && keyPair !== void 0 && keyPair.publicKey ? JSON.stringify(keyPair.publicKey) : null\n      },\n      auth: {\n        username,\n        deviceId\n      },\n      forceNew: true\n    });\n\n    // Set a timeout to disconnect from base node after relay connection is established\n    const relayConnectionTimeout = setTimeout(() => {\n      if (!socketRef.current || !socketRef.current.connected) {\n        console.log('Relay connection timed out, staying with base node');\n        socketRef.current = oldSocket; // Restore old socket\n        setStatus('Using Base Node (relay connection failed)');\n        setRelayServerUrl('Base Node (Fallback)');\n        setConnectionDetails(prev => ({\n          ...prev,\n          relayStatus: 'direct_to_base'\n        }));\n\n        // Connect socket events if they weren't already connected\n        connectSocketEvents();\n\n        // Start ping interval\n        startPingInterval();\n\n        // Start polling for available relays\n        startRelayPolling();\n      }\n    }, 5000);\n    socketRef.current.on('connect', () => {\n      clearTimeout(relayConnectionTimeout);\n      console.log(`Connected to relay server: ${relayUrl}`);\n\n      // Register with the relay\n      socketRef.current.emit('register', {\n        username,\n        deviceId,\n        publicKey: keyPair === null || keyPair === void 0 ? void 0 : keyPair.publicKey\n      }, response => {\n        console.log('Relay registration response:', response);\n        if (response && response.success) {\n          setStatus('Connected to relay server');\n          setRelayServerUrl(relayUrl);\n\n          // Update connection details\n          setConnectionDetails({\n            socketId: socketRef.current.id,\n            transport: socketRef.current.io.engine.transport.name,\n            baseNodeUrl: BASE_NODE_URL,\n            relayStatus: 'connected_to_relay',\n            ip: relayInfo.ip,\n            port: relayInfo.port,\n            connectedUsers: relayInfo.connectedUsers\n          });\n\n          // Disconnect from base node\n          if (oldSocket && oldSocket.connected) {\n            console.log('Disconnecting from base node');\n            oldSocket.disconnect();\n          }\n\n          // Connect socket events\n          connectSocketEvents();\n\n          // Start ping interval\n          startPingInterval();\n        } else {\n          console.error('Failed to register with relay:', response);\n          setStatus('Failed to register with relay server');\n\n          // Disconnect from relay and stay with base node\n          socketRef.current.disconnect();\n          socketRef.current = oldSocket;\n          setStatus('Using Base Node (relay registration failed)');\n          setRelayServerUrl('Base Node (Fallback)');\n          setConnectionDetails(prev => ({\n            ...prev,\n            relayStatus: 'direct_to_base'\n          }));\n\n          // Connect socket events\n          connectSocketEvents();\n\n          // Start ping interval\n          startPingInterval();\n\n          // Start polling for available relays\n          startRelayPolling();\n        }\n      });\n    });\n    socketRef.current.on('connect_error', err => {\n      clearTimeout(relayConnectionTimeout);\n      console.error(`Relay connection error: ${err.message}`);\n\n      // Stay with base node\n      socketRef.current = oldSocket;\n      setStatus('Using Base Node (relay connection failed)');\n      setRelayServerUrl('Base Node (Fallback)');\n      setConnectionDetails(prev => ({\n        ...prev,\n        relayStatus: 'direct_to_base'\n      }));\n\n      // Connect socket events\n      connectSocketEvents();\n\n      // Start ping interval\n      startPingInterval();\n\n      // Start polling for available relays\n      startRelayPolling();\n    });\n    socketRef.current.on('disconnect', reason => {\n      console.log(`Disconnected from relay: ${reason}`);\n\n      // If we were previously connected to a relay and lost connection\n      if (connectionDetails.relayStatus === 'connected_to_relay') {\n        setStatus(`Disconnected from relay: ${reason}`);\n\n        // Try to reconnect to base node\n        connectToBaseNode();\n      }\n    });\n  };\n  const startRelayPolling = () => {\n    // Clear any existing polling interval\n    if (window.relayPollingInterval) {\n      clearInterval(window.relayPollingInterval);\n    }\n\n    // Set up polling interval\n    window.relayPollingInterval = setInterval(() => {\n      if (socketRef.current && socketRef.current.connected && connectionDetails.relayStatus === 'direct_to_base') {\n        console.log('Polling for available relays...');\n        socketRef.current.emit('getAvailableRelays', {}, response => {\n          if (response && response.relays && response.relays.length > 0) {\n            console.log('Found available relays:', response.relays);\n\n            // Cache relay information\n            localStorage.setItem('whispernetRelayCache', JSON.stringify({\n              timestamp: Date.now(),\n              relays: response.relays\n            }));\n\n            // Connect to the first available relay\n            connectToRelay(response.relays[0]);\n\n            // Clear polling interval\n            clearInterval(window.relayPollingInterval);\n          } else {\n            console.log('No relays available, continuing to use base node');\n          }\n        });\n      }\n    }, 30000); // Poll every 30 seconds\n\n    // Clean up on component unmount\n    return () => {\n      if (window.relayPollingInterval) {\n        clearInterval(window.relayPollingInterval);\n      }\n    };\n  };\n  const connectSocketEvents = () => {\n    // Message handling\n    socketRef.current.on('receiveMessage', async data => {\n      console.log('Received message:', data);\n      const {\n        from,\n        message,\n        fromDeviceId,\n        timestamp,\n        encrypted,\n        publicKey,\n        bounced\n      } = data;\n\n      // Store sender's public key if provided\n      if (publicKey && from) {\n        console.log(`Storing public key for ${from}`);\n        setPublicKeys(prev => ({\n          ...prev,\n          [from]: publicKey\n        }));\n      }\n\n      // Security check for device ID changes\n      const previousMessages = messages.filter(msg => msg.from === from);\n      if (previousMessages.length > 0 && previousMessages[0].fromDeviceId && previousMessages[0].fromDeviceId !== fromDeviceId) {\n        setSecurityAlert({\n          username: from,\n          message: `Warning: ${from} appears to be messaging from a different device!`,\n          type: 'warning'\n        });\n      }\n      let decryptedMessage = message;\n      let decryptionStatus = 'plaintext';\n\n      // Decrypt the message if it's encrypted and we have our private key\n      if (encrypted && keyPair !== null && keyPair !== void 0 && keyPair.privateKey) {\n        try {\n          console.log('Decrypting message...');\n          decryptedMessage = await decryptMessage(message, keyPair.privateKey);\n          decryptionStatus = 'decrypted';\n          console.log('Message decrypted successfully');\n        } catch (error) {\n          console.error('Failed to decrypt message:', error);\n          decryptedMessage = '[Encrypted message - cannot decrypt]';\n          decryptionStatus = 'failed';\n          setSecurityAlert({\n            username: 'System',\n            message: `Failed to decrypt message from ${from}. Your keys may have changed.`,\n            type: 'warning'\n          });\n        }\n      }\n\n      // Create message object\n      const messageObj = {\n        from,\n        message: decryptedMessage,\n        fromDeviceId,\n        timestamp: new Date(timestamp || new Date()),\n        encrypted,\n        decryptionStatus,\n        bounced\n      };\n\n      // Add to messages array for current view\n      setMessages(msgs => [...msgs, messageObj]);\n\n      // Update chat history for this contact\n      updateChatHistory(from, messageObj);\n\n      // Update trust status - mark that we received a message from this user\n      updateTrustStatus(from, {\n        receivedMessage: true\n      });\n    });\n\n    // Handle public key requests\n    socketRef.current.on('publicKeyRequest', ({\n      from\n    }, ack) => {\n      console.log(`Public key requested by ${from}`);\n      if (keyPair && keyPair.publicKey) {\n        console.log(`Sending public key to ${from}`);\n        if (ack) ack({\n          success: true,\n          publicKey: keyPair.publicKey\n        });\n      } else {\n        console.warn('No public key available to share');\n        if (ack) ack({\n          success: false,\n          reason: 'Public key not available'\n        });\n      }\n    });\n\n    // User status updates\n    socketRef.current.on('userStatusUpdate', data => {\n      console.log('User status update:', data);\n      const {\n        username: user,\n        online\n      } = data;\n\n      // If this is our current recipient, update their status\n      if (user === recipient) {\n        console.log(`Updating status for current recipient ${user} to ${online ? 'online' : 'offline'}`);\n        setRecipientStatus(prev => ({\n          ...prev,\n          exists: true,\n          // If we got a status update, the user definitely exists\n          online,\n          notRegisteredYet: false // Clear this flag since we know the user exists\n        }));\n      }\n\n      // Update online users list\n      setOnlineUsers(prev => {\n        if (online && !prev.includes(user)) {\n          console.log(`Adding ${user} to online users list`);\n          return [...prev, user];\n        } else if (!online && prev.includes(user)) {\n          console.log(`Removing ${user} from online users list`);\n          return prev.filter(u => u !== user);\n        }\n        return prev;\n      });\n\n      // If we have a recipient, check if they're in the online users list\n      if (recipient) {\n        checkRecipientStatus();\n      }\n    });\n\n    // Handle bulk online users updates\n    socketRef.current.on('onlineUsersUpdate', data => {\n      console.log('Online users update:', data);\n      if (data && Array.isArray(data.users)) {\n        setOnlineUsers(data.users);\n\n        // If we have a recipient, check if they're in the online users list\n        if (recipient) {\n          const isOnline = data.users.includes(recipient);\n          console.log(`Recipient ${recipient} is ${isOnline ? 'online' : 'offline'}`);\n          setRecipientStatus(prev => ({\n            ...prev,\n            exists: prev.exists,\n            // Keep existing value\n            online: isOnline,\n            notRegisteredYet: false // Clear this flag since we got an update\n          }));\n        }\n      }\n    });\n\n    // Typing indicators\n    socketRef.current.on('userTyping', data => {\n      const {\n        username: typingUser\n      } = data;\n      if (typingUser === recipient) {\n        setTyping(true);\n        clearTimeout(typingTimeoutRef.current);\n        typingTimeoutRef.current = setTimeout(() => setTyping(false), 3000);\n      }\n    });\n\n    // Error handling\n    socketRef.current.on('error', error => {\n      console.error('Socket error:', error);\n      setSecurityAlert({\n        username: 'System',\n        message: `Connection error: ${error.message || 'Unknown error'}`,\n        type: 'error'\n      });\n    });\n\n    // Request online users list\n    if (socketRef.current && socketRef.current.connected) {\n      socketRef.current.emit('getOnlineUsers', {}, response => {\n        if (response && Array.isArray(response.users)) {\n          console.log('Online users:', response.users);\n          setOnlineUsers(response.users);\n        }\n      });\n    }\n  };\n  const startPingInterval = () => {\n    pingIntervalRef.current = setInterval(() => {\n      if (socketRef.current && socketRef.current.connected) {\n        // Send ping to keep connection alive\n        socketRef.current.emit('ping', {}, response => {\n          if (response) {\n            console.log('Ping response:', response);\n          }\n        });\n\n        // Request online users list\n        socketRef.current.emit('getOnlineUsers', {}, response => {\n          if (response && Array.isArray(response.users)) {\n            console.log('Online users:', response.users);\n            setOnlineUsers(response.users);\n          }\n        });\n      }\n    }, 30000); // Ping every 30 seconds\n  };\n  const checkRecipientStatus = () => {\n    if (!recipient || !socketRef.current || !socketRef.current.connected) {\n      return;\n    }\n    console.log(`Checking status for recipient: ${recipient}`);\n\n    // Check if the recipient is in the online users list\n    const isOnline = onlineUsers.includes(recipient);\n\n    // Check if the user exists\n    socketRef.current.emit('checkUser', {\n      username: recipient\n    }, response => {\n      console.log('Check user response:', response);\n      if (response && response.exists) {\n        setRecipientStatus({\n          exists: true,\n          online: isOnline,\n          notRegisteredYet: false\n        });\n      } else {\n        setRecipientStatus({\n          exists: false,\n          online: false,\n          notRegisteredYet: true\n        });\n      }\n    });\n  };\n  const handleRecipientChange = e => {\n    const newRecipient = e.target.value.trim();\n    setRecipient(newRecipient);\n    if (newRecipient) {\n      // Use a small delay to avoid too many checks while typing\n      if (recipientCheckTimeoutRef.current) {\n        clearTimeout(recipientCheckTimeoutRef.current);\n      }\n      recipientCheckTimeoutRef.current = setTimeout(() => {\n        checkRecipientStatus();\n      }, 500); // 500ms delay\n    }\n  };\n  const handleSend = async (e, bounce = false) => {\n    e.preventDefault();\n    if (!recipient || !message.trim() || !socketRef.current) return;\n    try {\n      // Show sending indicator\n      setStatus('Sending message...');\n\n      // If this is a relay/bounce message, we'll proceed regardless of recipient status\n      if (!bounce) {\n        // For direct messages, we need to check if the recipient exists and is online\n        const recipientOnline = recipientStatus.online;\n\n        // If recipient is not online, suggest using relay\n        if (!recipientOnline) {\n          setSecurityAlert({\n            username: 'System',\n            message: `${recipient} is offline or not found. Use the RELAY button to send a delayed message.`,\n            type: 'warning'\n          });\n          setStatus('Registered successfully');\n          return;\n        }\n      }\n\n      // Get recipient's public key if we don't have it and encryption is enabled\n      if (encryptionEnabled && !publicKeys[recipient]) {\n        try {\n          await requestPublicKey(recipient);\n        } catch (error) {\n          console.error('Failed to get public key:', error);\n          // Continue without encryption if we can't get the key\n        }\n      }\n      let finalMessage = message.trim();\n      let isEncrypted = false;\n\n      // Encrypt the message if encryption is enabled and we have the recipient's public key\n      if (encryptionEnabled && publicKeys[recipient]) {\n        try {\n          finalMessage = await encryptMessage(message.trim(), publicKeys[recipient]);\n          isEncrypted = true;\n          console.log('Message encrypted successfully');\n        } catch (error) {\n          console.error('Failed to encrypt message:', error);\n          setSecurityAlert({\n            username: 'System',\n            message: 'Failed to encrypt message. Sending as plaintext.',\n            type: 'warning'\n          });\n        }\n      }\n      const messageData = {\n        to: recipient,\n        message: finalMessage,\n        deviceId,\n        timestamp: new Date().toISOString(),\n        bounce: bounce,\n        // Always use the bounce parameter directly\n        encrypted: isEncrypted,\n        publicKey: keyPair === null || keyPair === void 0 ? void 0 : keyPair.publicKey // Send our public key with the message\n      };\n      console.log('Sending message:', {\n        ...messageData,\n        message: isEncrypted ? '[ENCRYPTED]' : finalMessage,\n        bounce: bounce\n      });\n\n      // Add a timeout to handle cases where the server doesn't respond\n      const messageTimeout = setTimeout(() => {\n        setSecurityAlert({\n          username: 'System',\n          message: 'Message sending timed out. Server may be offline.',\n          type: 'error'\n        });\n        setStatus('Registered successfully');\n      }, 10000);\n      socketRef.current.emit('sendMessage', messageData, response => {\n        clearTimeout(messageTimeout);\n        console.log('Send message response:', response);\n        setStatus('Registered successfully');\n        if (response && (response.delivered || response.bounced)) {\n          // Create message object\n          const messageObj = {\n            from: username,\n            message: message.trim(),\n            // Store original message for display\n            fromDeviceId: deviceId,\n            timestamp: new Date(),\n            status: response.delivered ? 'delivered' : 'bounced',\n            expiresAt: response.expiresAt,\n            encrypted: isEncrypted\n          };\n\n          // Add message to local state (store original message for display)\n          setMessages(msgs => [...msgs, messageObj]);\n\n          // Update chat history for this contact\n          updateChatHistory(recipient, messageObj);\n\n          // Update trust status - mark that we sent a message to this user\n          updateTrustStatus(recipient, {\n            sentMessage: true\n          });\n          setMessage('');\n\n          // Show notification if message was bounced\n          if (response.bounced) {\n            setSecurityAlert({\n              username: 'System',\n              message: `Message to ${recipient} will be delivered when they come online (expires in 4 hours)`,\n              type: 'info'\n            });\n          }\n        } else {\n          const errorMsg = (response === null || response === void 0 ? void 0 : response.reason) || 'Message delivery failed';\n          if (errorMsg.includes('not found') || errorMsg.includes('User not found')) {\n            if (bounce) {\n              // For bounced messages to non-existent users, show a special message\n              setSecurityAlert({\n                username: 'System',\n                message: `Message will be delivered if ${recipient} registers within 4 hours.`,\n                type: 'info'\n              });\n\n              // Create message object\n              const messageObj = {\n                from: username,\n                message: message.trim(),\n                fromDeviceId: deviceId,\n                timestamp: new Date(),\n                status: 'bounced',\n                expiresAt: Date.now() + 14400000,\n                // 4 hours\n                encrypted: isEncrypted\n              };\n\n              // Add message to local state as bounced\n              setMessages(msgs => [...msgs, messageObj]);\n\n              // Update chat history for this contact\n              updateChatHistory(recipient, messageObj);\n\n              // Update trust status - mark that we sent a message to this user\n              updateTrustStatus(recipient, {\n                sentMessage: true\n              });\n              setMessage('');\n            } else {\n              setSecurityAlert({\n                username: 'System',\n                message: `${recipient} not found. Use the RELAY button to send a message that will be delivered if they register.`,\n                type: 'warning'\n              });\n            }\n          } else if (errorMsg.includes('offline')) {\n            setSecurityAlert({\n              username: 'System',\n              message: `${recipient} is offline. Use the RELAY button to send a delayed message.`,\n              type: 'warning'\n            });\n          } else {\n            setSecurityAlert({\n              username: 'System',\n              message: `Failed to send message: ${errorMsg}`,\n              type: 'error'\n            });\n          }\n        }\n      });\n    } catch (error) {\n      console.error('Error sending message:', error);\n      setSecurityAlert({\n        username: 'System',\n        message: `Error sending message: ${error.message}`,\n        type: 'error'\n      });\n      setStatus('Registered successfully');\n    }\n  };\n\n  // Request public key from a user\n  const requestPublicKey = async username => {\n    return new Promise((resolve, reject) => {\n      if (!socketRef.current) {\n        reject(new Error('Not connected'));\n        return;\n      }\n      console.log(`Requesting public key for ${username}...`);\n\n      // Set a timeout in case the server doesn't respond\n      const requestTimeout = setTimeout(() => {\n        console.error(`Public key request for ${username} timed out`);\n        reject(new Error('Request timed out'));\n      }, 10000);\n      socketRef.current.emit('requestPublicKey', {\n        username\n      }, response => {\n        clearTimeout(requestTimeout);\n        if (response && response.success && response.publicKey) {\n          console.log(`Received public key for ${username}`);\n          setPublicKeys(prev => ({\n            ...prev,\n            [username]: response.publicKey\n          }));\n          resolve(response.publicKey);\n        } else {\n          const reason = (response === null || response === void 0 ? void 0 : response.reason) || 'Public key not available';\n          console.log(`No public key available for ${username}: ${reason}`);\n          reject(new Error(reason));\n        }\n      });\n    });\n  };\n  const handleBounce = e => {\n    if (!recipient || !message.trim()) {\n      return;\n    }\n\n    // Show confirmation before bouncing\n    const confirmBounce = window.confirm(`RELAY MESSAGE\\n\\n` + `Your message to \"${recipient}\" will be stored on ${connectionDetails.relayStatus === 'connected_to_relay' ? 'relay' : 'base node'} servers for up to 4 hours.\\n\\n` + `It will be delivered when ${recipient} comes online or registers with the network.\\n\\n` + `Continue?`);\n    if (confirmBounce) {\n      handleSend(e, true);\n    }\n  };\n  const handleMessageChange = e => {\n    setMessage(e.target.value);\n\n    // Send typing indicator\n    if (socketRef.current && recipient && e.target.value.length > 0) {\n      socketRef.current.emit('typing', {\n        to: recipient\n      });\n    }\n  };\n  const dismissAlert = () => {\n    setSecurityAlert(null);\n  };\n  const retryConnection = () => {\n    checkRelayStatus();\n  };\n\n  // Utility functions\n  const getTimestamp = () => {\n    const now = new Date();\n    return `[${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}]`;\n  };\n  const formatMessageTime = timestamp => {\n    if (!timestamp) return getTimestamp();\n    const date = new Date(timestamp);\n    return `[${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}]`;\n  };\n\n  // Function to switch to a specific chat\n  const switchToChat = contactUsername => {\n    setActiveChat(contactUsername);\n    setRecipient(contactUsername || '');\n\n    // Load messages for this contact\n    if (contactUsername && chatHistory[contactUsername]) {\n      setMessages(chatHistory[contactUsername]);\n    } else {\n      setMessages([]);\n    }\n\n    // Check if we need to show trust warning\n    if (contactUsername && trustStatus[contactUsername]) {\n      setShowTrustWarning(!trustStatus[contactUsername].mutualMessaging);\n    } else if (contactUsername) {\n      setShowTrustWarning(true);\n    } else {\n      setShowTrustWarning(false);\n    }\n  };\n\n  // Function to toggle About page\n  const toggleAboutPage = () => {\n    setShowAboutPage(!showAboutPage);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      background: '#0a0e14',\n      minHeight: '100vh',\n      color: '#a2aabc',\n      display: 'flex',\n      flexDirection: 'column',\n      fontFamily: '\"Fira Code\", monospace'\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"header\", {\n      style: {\n        background: '#171c28',\n        padding: '16px 24px',\n        borderBottom: '1px solid rgba(0, 255, 170, 0.3)',\n        display: 'flex',\n        justifyContent: 'space-between',\n        alignItems: 'center'\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          display: 'flex',\n          alignItems: 'center'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n          style: {\n            margin: 0,\n            color: '#5ccfe6',\n            fontFamily: '\"Fira Code\", monospace',\n            letterSpacing: '1px',\n            fontSize: '24px'\n          },\n          children: \"WhisperNet_\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1401,\n          columnNumber: 11\n        }, this), username && /*#__PURE__*/_jsxDEV(\"span\", {\n          style: {\n            marginLeft: '16px',\n            color: '#bae67e',\n            fontSize: '14px',\n            padding: '4px 8px',\n            background: 'rgba(186, 230, 126, 0.1)',\n            borderRadius: '4px'\n          },\n          children: [\"@\", username]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1410,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1400,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          display: 'flex',\n          alignItems: 'center'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            fontSize: 12,\n            padding: '4px 8px',\n            borderRadius: 4,\n            background: relayStatus === 'online' ? '#1c4b3c' : '#4b1c1c',\n            color: relayStatus === 'online' ? '#5ccfe6' : '#ff8f40',\n            cursor: 'pointer',\n            marginRight: '12px'\n          },\n          onClick: () => setShowConnectionInfo(!showConnectionInfo),\n          children: relayStatus === 'online' ? 'Base Node Online' : relayStatus === 'checking' ? 'Checking...' : 'Base Node Offline'\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1424,\n          columnNumber: 11\n        }, this), connected && /*#__PURE__*/_jsxDEV(\"button\", {\n          style: {\n            padding: '8px 16px',\n            borderRadius: 4,\n            background: '#4b1c1c',\n            color: '#ff8f40',\n            fontSize: 14,\n            border: 'none',\n            cursor: 'pointer',\n            fontFamily: '\"Fira Code\", monospace',\n            marginRight: '12px'\n          },\n          onClick: handleDisconnect,\n          children: \"DISCONNECT\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1438,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          style: {\n            padding: '8px 16px',\n            borderRadius: 4,\n            background: '#1c3b4b',\n            color: '#5ccfe6',\n            fontSize: 14,\n            border: 'none',\n            cursor: 'pointer',\n            fontFamily: '\"Fira Code\", monospace'\n          },\n          onClick: toggleAboutPage,\n          children: showAboutPage ? 'BACK TO CHAT' : 'ABOUT'\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1456,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1423,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1392,\n      columnNumber: 7\n    }, this), showConnectionInfo && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        padding: '0 24px'\n      },\n      children: /*#__PURE__*/_jsxDEV(ConnectionInfo, {\n        status: status,\n        connected: connected,\n        connectionDetails: connectionDetails,\n        relayServerUrl: relayServerUrl,\n        relayStatus: relayStatus,\n        deviceId: deviceId,\n        BASE_NODE_URL: BASE_NODE_URL\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1477,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1476,\n      columnNumber: 9\n    }, this), securityAlert && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        padding: '0 24px'\n      },\n      children: /*#__PURE__*/_jsxDEV(SecurityAlert, {\n        alert: securityAlert,\n        onDismiss: dismissAlert\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1492,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1491,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        flex: 1,\n        display: 'flex',\n        height: 'calc(100vh - 69px - (showConnectionInfo ? 80 : 0) - (securityAlert ? 60 : 0))' // Subtract header height and optional elements\n      },\n      children: showAboutPage ? /*#__PURE__*/_jsxDEV(AboutPage, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1503,\n        columnNumber: 11\n      }, this) : !connected ? /*#__PURE__*/_jsxDEV(LoginScreen, {\n        username: username,\n        handleUsernameChange: handleUsernameChange,\n        handleUsernameSubmit: handleUsernameSubmit,\n        isCheckingUsername: isCheckingUsername,\n        usernameAvailable: usernameAvailable,\n        relayStatus: relayStatus,\n        status: status,\n        securityAlert: securityAlert,\n        dismissAlert: dismissAlert,\n        retryConnection: retryConnection,\n        getTimestamp: getTimestamp\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1505,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(ChatInterface, {\n        contacts: contacts,\n        activeChat: activeChat,\n        switchToChat: switchToChat,\n        onlineUsers: onlineUsers,\n        trustStatus: trustStatus,\n        recipient: recipient,\n        handleRecipientChange: handleRecipientChange,\n        message: message,\n        handleMessageChange: handleMessageChange,\n        handleSend: handleSend,\n        handleBounce: handleBounce,\n        recipientStatus: recipientStatus,\n        messages: messages,\n        username: username,\n        typing: typing,\n        messagesEndRef: messagesEndRef,\n        formatMessageTime: formatMessageTime,\n        getTimestamp: getTimestamp,\n        showTrustWarning: showTrustWarning\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1519,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1497,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1383,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"k1FAj4IO3rcy5/+VwcZ4YOdbLA4=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useRef","useEffect","io","axios","FingerprintJS","ConnectionInfo","SecurityAlert","LoginScreen","ChatInterface","AboutPage","jsxDEV","_jsxDEV","BASE_NODE_URL","process","env","REACT_APP_BASE_NODE_URL","IDENTITY_STORAGE_KEY","CHAT_HISTORY_KEY","TRUST_STATUS_KEY","generateKeyPair","keyPair","window","crypto","subtle","generateKey","name","modulusLength","publicExponent","Uint8Array","hash","publicKey","exportKey","privateKey","error","console","encryptMessage","message","publicKeyJwk","importKey","encoder","TextEncoder","data","encode","encryptedData","encrypt","btoa","String","fromCharCode","decryptMessage","encryptedMessage","privateKeyJwk","atob","split","map","char","charCodeAt","decryptedData","decrypt","decoder","TextDecoder","decode","App","_s","connected","setConnected","username","setUsername","deviceId","setDeviceId","status","setStatus","relayStatus","setRelayStatus","relayServerUrl","setRelayServerUrl","connectionDetails","setConnectionDetails","showConnectionInfo","setShowConnectionInfo","securityAlert","setSecurityAlert","recipient","setRecipient","setMessage","messages","setMessages","typing","setTyping","onlineUsers","setOnlineUsers","recipientStatus","setRecipientStatus","exists","online","isCheckingUsername","setIsCheckingUsername","usernameAvailable","setUsernameAvailable","setKeyPair","publicKeys","setPublicKeys","encryptionEnabled","setEncryptionEnabled","encryptionStatus","setEncryptionStatus","knownIdentities","setKnownIdentities","identityMismatch","setIdentityMismatch","showIdentityWarning","setShowIdentityWarning","chatHistory","setChatHistory","contacts","setContacts","activeChat","setActiveChat","trustStatus","setTrustStatus","showTrustWarning","setShowTrustWarning","showAboutPage","setShowAboutPage","socketRef","messagesEndRef","typingTimeoutRef","pingIntervalRef","recipientCheckTimeoutRef","loadKnownIdentities","storedIdentities","localStorage","getItem","JSON","parse","saveKnownIdentities","identities","setItem","stringify","loadChatHistory","storedChatHistory","parsedChatHistory","contactsList","Object","keys","log","length","saveChatHistory","history","loadTrustStatus","storedTrustStatus","saveTrustStatus","updateChatHistory","contact","prevHistory","updatedHistory","includes","updatedContacts","updateTrustStatus","updates","prevStatus","updatedStatus","trusted","keyExchanged","mutualMessaging","sentMessage","receivedMessage","firstInteraction","Date","toISOString","initializeFingerprint","fp","load","result","get","visitorId","checkRelayStatus","current","scrollIntoView","behavior","disconnect","clearInterval","clearTimeout","response","timeout","tempSocket","transports","reconnectionAttempts","reconnectionDelay","forceNew","on","err","connectToBaseNode","handleUsernameSubmit","e","preventDefault","trim","available","newKeyPair","type","handleUsernameChange","newUsername","target","value","usernameCheckTimeout","setTimeout","handleDisconnect","query","auth","id","socketId","transport","engine","baseNodeUrl","emit","success","connectSocketEvents","startPingInterval","relays","timestamp","now","connectToRelay","startRelayPolling","reason","cachedRelayInfo","relayInfo","cacheAge","url","relayUrl","oldSocket","relayConnectionTimeout","prev","ip","port","connectedUsers","relayPollingInterval","setInterval","from","fromDeviceId","encrypted","bounced","previousMessages","filter","msg","decryptedMessage","decryptionStatus","messageObj","msgs","ack","warn","user","notRegisteredYet","u","checkRecipientStatus","Array","isArray","users","isOnline","typingUser","handleRecipientChange","newRecipient","handleSend","bounce","recipientOnline","requestPublicKey","finalMessage","isEncrypted","messageData","to","messageTimeout","delivered","expiresAt","errorMsg","Promise","resolve","reject","Error","requestTimeout","handleBounce","confirmBounce","confirm","handleMessageChange","dismissAlert","retryConnection","getTimestamp","getHours","toString","padStart","getMinutes","getSeconds","formatMessageTime","date","switchToChat","contactUsername","toggleAboutPage","style","background","minHeight","color","display","flexDirection","fontFamily","children","padding","borderBottom","justifyContent","alignItems","margin","letterSpacing","fontSize","fileName","_jsxFileName","lineNumber","columnNumber","marginLeft","borderRadius","cursor","marginRight","onClick","border","alert","onDismiss","flex","height","_c","$RefreshReg$"],"sources":["C:/Users/siddharth/Documents/GitHub/WhisperNet/frontend/src/App.js"],"sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\r\nimport io from 'socket.io-client';\r\nimport axios from 'axios';\r\nimport FingerprintJS from '@fingerprintjs/fingerprintjs';\r\n\r\n// Import components\r\nimport ConnectionInfo from './components/ConnectionInfo';\r\nimport SecurityAlert from './components/SecurityAlert';\r\nimport LoginScreen from './components/LoginScreen';\r\nimport ChatInterface from './components/ChatInterface';\r\nimport AboutPage from './components/AboutPage';\r\n\r\nconst BASE_NODE_URL = process.env.REACT_APP_BASE_NODE_URL || \"http://localhost:5000\";\r\n\r\n// Storage keys\r\nconst IDENTITY_STORAGE_KEY = 'whispernetKnownIdentities';\r\nconst CHAT_HISTORY_KEY = 'whispernetChatHistory';\r\nconst TRUST_STATUS_KEY = 'whispernetTrustStatus';\r\n\r\n// Encryption utilities\r\nconst generateKeyPair = async () => {\r\n  try {\r\n    const keyPair = await window.crypto.subtle.generateKey(\r\n      {\r\n        name: \"RSA-OAEP\",\r\n        modulusLength: 2048,\r\n        publicExponent: new Uint8Array([1, 0, 1]),\r\n        hash: \"SHA-256\",\r\n      },\r\n      true,\r\n      [\"encrypt\", \"decrypt\"]\r\n    );\r\n    \r\n    // Export the keys to JWK format\r\n    const publicKey = await window.crypto.subtle.exportKey(\"jwk\", keyPair.publicKey);\r\n    const privateKey = await window.crypto.subtle.exportKey(\"jwk\", keyPair.privateKey);\r\n    \r\n    return { publicKey, privateKey };\r\n  } catch (error) {\r\n    console.error('Error generating key pair:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nconst encryptMessage = async (message, publicKeyJwk) => {\r\n  try {\r\n    // Import the public key\r\n    const publicKey = await window.crypto.subtle.importKey(\r\n      \"jwk\",\r\n      publicKeyJwk,\r\n      {\r\n        name: \"RSA-OAEP\",\r\n        hash: \"SHA-256\",\r\n      },\r\n      false,\r\n      [\"encrypt\"]\r\n    );\r\n    \r\n    // Convert the message to an ArrayBuffer\r\n    const encoder = new TextEncoder();\r\n    const data = encoder.encode(message);\r\n    \r\n    // Encrypt the data\r\n    const encryptedData = await window.crypto.subtle.encrypt(\r\n      {\r\n        name: \"RSA-OAEP\"\r\n      },\r\n      publicKey,\r\n      data\r\n    );\r\n    \r\n    // Convert the encrypted data to a base64 string\r\n    return btoa(String.fromCharCode(...new Uint8Array(encryptedData)));\r\n  } catch (error) {\r\n    console.error('Error encrypting message:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nconst decryptMessage = async (encryptedMessage, privateKeyJwk) => {\r\n  try {\r\n    // Import the private key\r\n    const privateKey = await window.crypto.subtle.importKey(\r\n      \"jwk\",\r\n      privateKeyJwk,\r\n      {\r\n        name: \"RSA-OAEP\",\r\n        hash: \"SHA-256\",\r\n      },\r\n      false,\r\n      [\"decrypt\"]\r\n    );\r\n    \r\n    // Convert the base64 string to an ArrayBuffer\r\n    const encryptedData = new Uint8Array(\r\n      atob(encryptedMessage)\r\n        .split('')\r\n        .map(char => char.charCodeAt(0))\r\n    );\r\n    \r\n    // Decrypt the data\r\n    const decryptedData = await window.crypto.subtle.decrypt(\r\n      {\r\n        name: \"RSA-OAEP\"\r\n      },\r\n      privateKey,\r\n      encryptedData\r\n    );\r\n    \r\n    // Convert the decrypted data to a string\r\n    const decoder = new TextDecoder();\r\n    return decoder.decode(decryptedData);\r\n  } catch (error) {\r\n    console.error('Error decrypting message:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nfunction App() {\r\n  // Connection state\r\n  const [connected, setConnected] = useState(false);\r\n  const [username, setUsername] = useState('');\r\n  const [deviceId, setDeviceId] = useState('');\r\n  const [status, setStatus] = useState('Initializing...');\r\n  const [relayStatus, setRelayStatus] = useState('checking');\r\n  const [relayServerUrl, setRelayServerUrl] = useState('');\r\n  const [connectionDetails, setConnectionDetails] = useState({});\r\n  const [showConnectionInfo, setShowConnectionInfo] = useState(false);\r\n  const [securityAlert, setSecurityAlert] = useState(null);\r\n  \r\n  // Message state\r\n  const [recipient, setRecipient] = useState('');\r\n  const [message, setMessage] = useState('');\r\n  const [messages, setMessages] = useState([]);\r\n  const [typing, setTyping] = useState(false);\r\n  const [onlineUsers, setOnlineUsers] = useState([]);\r\n  const [recipientStatus, setRecipientStatus] = useState({ exists: false, online: false });\r\n  const [isCheckingUsername, setIsCheckingUsername] = useState(false);\r\n  const [usernameAvailable, setUsernameAvailable] = useState(true);\r\n  \r\n  // Encryption state\r\n  const [keyPair, setKeyPair] = useState(null);\r\n  const [publicKeys, setPublicKeys] = useState({});\r\n  const [encryptionEnabled, setEncryptionEnabled] = useState(true);\r\n  const [encryptionStatus, setEncryptionStatus] = useState('initializing');\r\n  const [knownIdentities, setKnownIdentities] = useState({}); // username -> {deviceId, publicKey, firstSeen}\r\n  const [identityMismatch, setIdentityMismatch] = useState(null); // {username, originalDeviceId, newDeviceId, action}\r\n  const [showIdentityWarning, setShowIdentityWarning] = useState(false);\r\n  \r\n  // New state variables for enhanced chat functionality\r\n  const [chatHistory, setChatHistory] = useState({}); // username -> array of messages\r\n  const [contacts, setContacts] = useState([]); // list of usernames the current user has chatted with\r\n  const [activeChat, setActiveChat] = useState(null); // currently selected chat\r\n  const [trustStatus, setTrustStatus] = useState({}); // username -> {trusted: boolean, keyExchanged: boolean, mutualMessaging: boolean}\r\n  const [showTrustWarning, setShowTrustWarning] = useState(false); // whether to show the trust warning for the current chat\r\n  \r\n  // UI state variables\r\n  const [showAboutPage, setShowAboutPage] = useState(false); // whether to show the About page\r\n  \r\n  const socketRef = useRef(null);\r\n  const messagesEndRef = useRef(null);\r\n  const typingTimeoutRef = useRef(null);\r\n  const pingIntervalRef = useRef(null);\r\n  const recipientCheckTimeoutRef = useRef(null);\r\n\r\n  // Load known identities from localStorage\r\n  const loadKnownIdentities = () => {\r\n    try {\r\n      const storedIdentities = localStorage.getItem(IDENTITY_STORAGE_KEY);\r\n      if (storedIdentities) {\r\n        setKnownIdentities(JSON.parse(storedIdentities));\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading known identities:', error);\r\n    }\r\n  };\r\n  \r\n  // Save known identities to localStorage\r\n  const saveKnownIdentities = (identities) => {\r\n    try {\r\n      localStorage.setItem(IDENTITY_STORAGE_KEY, JSON.stringify(identities));\r\n    } catch (error) {\r\n      console.error('Error saving known identities:', error);\r\n    }\r\n  };\r\n  \r\n  // Load chat history from localStorage\r\n  const loadChatHistory = () => {\r\n    try {\r\n      const storedChatHistory = localStorage.getItem(CHAT_HISTORY_KEY);\r\n      if (storedChatHistory) {\r\n        const parsedChatHistory = JSON.parse(storedChatHistory);\r\n        setChatHistory(parsedChatHistory);\r\n        \r\n        // Extract contacts from chat history\r\n        const contactsList = Object.keys(parsedChatHistory);\r\n        setContacts(contactsList);\r\n        console.log('Loaded chat history for contacts:', contactsList.length);\r\n        \r\n        // If we have contacts but no active chat, set the first contact as active\r\n        if (contactsList.length > 0 && !activeChat) {\r\n          setActiveChat(contactsList[0]);\r\n          setRecipient(contactsList[0]);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading chat history:', error);\r\n    }\r\n  };\r\n  \r\n  // Save chat history to localStorage\r\n  const saveChatHistory = (history) => {\r\n    try {\r\n      localStorage.setItem(CHAT_HISTORY_KEY, JSON.stringify(history));\r\n    } catch (error) {\r\n      console.error('Error saving chat history:', error);\r\n    }\r\n  };\r\n  \r\n  // Load trust status from localStorage\r\n  const loadTrustStatus = () => {\r\n    try {\r\n      const storedTrustStatus = localStorage.getItem(TRUST_STATUS_KEY);\r\n      if (storedTrustStatus) {\r\n        setTrustStatus(JSON.parse(storedTrustStatus));\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading trust status:', error);\r\n    }\r\n  };\r\n  \r\n  // Save trust status to localStorage\r\n  const saveTrustStatus = (status) => {\r\n    try {\r\n      localStorage.setItem(TRUST_STATUS_KEY, JSON.stringify(status));\r\n    } catch (error) {\r\n      console.error('Error saving trust status:', error);\r\n    }\r\n  };\r\n  \r\n  // Update chat history for a specific contact\r\n  const updateChatHistory = (contact, message) => {\r\n    setChatHistory(prevHistory => {\r\n      const updatedHistory = { ...prevHistory };\r\n      \r\n      // Initialize chat history for this contact if it doesn't exist\r\n      if (!updatedHistory[contact]) {\r\n        updatedHistory[contact] = [];\r\n      }\r\n      \r\n      // Add the message to the chat history\r\n      updatedHistory[contact] = [...updatedHistory[contact], message];\r\n      \r\n      // Save the updated chat history\r\n      saveChatHistory(updatedHistory);\r\n      \r\n      // Update contacts list if this is a new contact\r\n      if (!contacts.includes(contact)) {\r\n        const updatedContacts = [...contacts, contact];\r\n        setContacts(updatedContacts);\r\n      }\r\n      \r\n      return updatedHistory;\r\n    });\r\n  };\r\n  \r\n  // Check and update trust status for a contact\r\n  const updateTrustStatus = (contact, updates) => {\r\n    setTrustStatus(prevStatus => {\r\n      const updatedStatus = { ...prevStatus };\r\n      \r\n      // Initialize trust status for this contact if it doesn't exist\r\n      if (!updatedStatus[contact]) {\r\n        updatedStatus[contact] = {\r\n          trusted: false,\r\n          keyExchanged: false,\r\n          mutualMessaging: false,\r\n          sentMessage: false,\r\n          receivedMessage: false,\r\n          firstInteraction: new Date().toISOString()\r\n        };\r\n      }\r\n      \r\n      // Apply updates\r\n      updatedStatus[contact] = {\r\n        ...updatedStatus[contact],\r\n        ...updates\r\n      };\r\n      \r\n      // Check if mutual messaging has occurred\r\n      if (updatedStatus[contact].sentMessage && updatedStatus[contact].receivedMessage) {\r\n        updatedStatus[contact].mutualMessaging = true;\r\n        \r\n        // If mutual messaging has occurred and we have their public key, mark as trusted and exchange keys\r\n        if (publicKeys[contact]) {\r\n          updatedStatus[contact].keyExchanged = true;\r\n          updatedStatus[contact].trusted = true;\r\n          \r\n          // Update the UI to show trust status change\r\n          if (contact === recipient) {\r\n            setShowTrustWarning(false);\r\n          }\r\n        }\r\n      } else {\r\n        // If we don't have mutual messaging yet, make sure to show the warning\r\n        if (contact === recipient) {\r\n          setShowTrustWarning(true);\r\n        }\r\n      }\r\n      \r\n      // Save the updated trust status\r\n      saveTrustStatus(updatedStatus);\r\n      \r\n      return updatedStatus;\r\n    });\r\n  };\r\n\r\n  // Initialize device fingerprint\r\n  useEffect(() => {\r\n    const initializeFingerprint = async () => {\r\n      try {\r\n        const fp = await FingerprintJS.load();\r\n        const result = await fp.get();\r\n        const deviceId = result.visitorId;\r\n        setDeviceId(deviceId);\r\n        console.log('Device fingerprint:', deviceId);\r\n      } catch (error) {\r\n        console.error('Error initializing fingerprint:', error);\r\n        setStatus('Error initializing device fingerprint');\r\n      }\r\n    };\r\n    \r\n    initializeFingerprint();\r\n    loadKnownIdentities();\r\n    loadChatHistory();\r\n    loadTrustStatus();\r\n    checkRelayStatus();\r\n    \r\n    // Scroll to bottom when messages change\r\n    if (messagesEndRef.current) {\r\n      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });\r\n    }\r\n    \r\n    return () => {\r\n      if (socketRef.current) {\r\n        socketRef.current.disconnect();\r\n      }\r\n      clearInterval(pingIntervalRef.current);\r\n      clearTimeout(recipientCheckTimeoutRef.current);\r\n      clearTimeout(typingTimeoutRef.current);\r\n    };\r\n  }, []);\r\n  \r\n  // Scroll to bottom when messages change\r\n  useEffect(() => {\r\n    if (messagesEndRef.current) {\r\n      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });\r\n    }\r\n  }, [messages]);\r\n  \r\n  // Update connection info when connection details change\r\n  useEffect(() => {\r\n    if (connected && showConnectionInfo) {\r\n      // Update connection info\r\n    }\r\n  }, [connected, showConnectionInfo, username]);\r\n\r\n  const checkRelayStatus = async () => {\r\n    setRelayStatus('checking');\r\n    setStatus('Checking base node status...');\r\n    \r\n    // Try HTTP health check first\r\n    try {\r\n      const response = await axios.get(`${BASE_NODE_URL}/health`, { \r\n        timeout: 5000 \r\n      });\r\n      \r\n      if (response.status === 200) {\r\n        setRelayStatus('online');\r\n        setStatus('Base node online. Please login.');\r\n        return;\r\n      }\r\n    } catch (error) {\r\n      console.log('HTTP health check failed, trying socket connection:', error.message);\r\n    }\r\n    \r\n    // Fallback to socket connection test\r\n    const tempSocket = io(BASE_NODE_URL, {\r\n      transports: ['websocket', 'polling'],\r\n      reconnectionAttempts: 2,\r\n      reconnectionDelay: 1000,\r\n      timeout: 5000,\r\n      forceNew: true\r\n    });\r\n    \r\n    tempSocket.on('connect', () => {\r\n      console.log('Connected to base node for status check');\r\n      setRelayStatus('online');\r\n      setStatus('Base node online. Please login.');\r\n      tempSocket.disconnect();\r\n    });\r\n    \r\n    tempSocket.on('connect_error', (err) => {\r\n      console.error('Base node connection error:', err);\r\n      setRelayStatus('offline');\r\n      setStatus('Base node offline. Please try again later.');\r\n      tempSocket.disconnect();\r\n    });\r\n  };\r\n\r\n  // Main socket connection effect\r\n  useEffect(() => {\r\n    if (connected && username && deviceId) {\r\n      connectToBaseNode();\r\n    }\r\n    \r\n    return () => {\r\n      if (socketRef.current) {\r\n        clearInterval(pingIntervalRef.current);\r\n        clearTimeout(recipientCheckTimeoutRef.current);\r\n        clearTimeout(typingTimeoutRef.current);\r\n        socketRef.current.disconnect();\r\n        socketRef.current = null;\r\n      }\r\n    };\r\n  }, [connected, username, deviceId]);\r\n\r\n  const handleUsernameSubmit = async (e) => {\r\n    e.preventDefault();\r\n    \r\n    if (!username.trim() || !deviceId) {\r\n      setStatus('Please enter a valid username');\r\n      return;\r\n    }\r\n    \r\n    if (relayStatus !== 'online') {\r\n      setStatus('Cannot connect: Base node is offline');\r\n      return;\r\n    }\r\n    \r\n    try {\r\n      setStatus('Checking username availability...');\r\n      setIsCheckingUsername(true);\r\n      \r\n      // Check if username is available\r\n      const response = await axios.get(`${BASE_NODE_URL}/check-username/${username}`, {\r\n        timeout: 5000\r\n      });\r\n      \r\n      setIsCheckingUsername(false);\r\n      \r\n      if (response.data.available) {\r\n        console.log('Username is available');\r\n        setUsernameAvailable(true);\r\n        \r\n        // Generate encryption keys if needed\r\n        if (!keyPair) {\r\n          setStatus('Generating encryption keys...');\r\n          try {\r\n            const newKeyPair = await generateKeyPair();\r\n            setKeyPair(newKeyPair);\r\n            setEncryptionStatus('ready');\r\n            console.log('Encryption keys generated successfully');\r\n          } catch (error) {\r\n            console.error('Failed to generate encryption keys:', error);\r\n            setEncryptionStatus('failed');\r\n            setSecurityAlert({\r\n              username: 'System',\r\n              message: 'Failed to generate encryption keys. Messages will not be encrypted.',\r\n              type: 'error'\r\n            });\r\n          }\r\n        }\r\n        \r\n        setConnected(true);\r\n        setStatus('Connecting to network...');\r\n      } else {\r\n        console.log('Username is already taken');\r\n        setUsernameAvailable(false);\r\n        setStatus('Username is already taken. Please choose another.');\r\n      }\r\n    } catch (error) {\r\n      console.error('Error checking username:', error);\r\n      setIsCheckingUsername(false);\r\n      setStatus('Error checking username. Please try again.');\r\n    }\r\n  };\r\n\r\n  const handleUsernameChange = (e) => {\r\n    const newUsername = e.target.value.trim();\r\n    setUsername(newUsername);\r\n    \r\n    // Reset availability check when username changes\r\n    setUsernameAvailable(true);\r\n    \r\n    // Check username availability after a short delay\r\n    if (newUsername.length > 2) {\r\n      setIsCheckingUsername(true);\r\n      clearTimeout(window.usernameCheckTimeout);\r\n      \r\n      window.usernameCheckTimeout = setTimeout(async () => {\r\n        try {\r\n          const response = await axios.get(`${BASE_NODE_URL}/check-username/${newUsername}`, {\r\n            timeout: 5000\r\n          });\r\n          \r\n          setIsCheckingUsername(false);\r\n          setUsernameAvailable(response.data.available);\r\n        } catch (error) {\r\n          console.error('Error checking username:', error);\r\n          setIsCheckingUsername(false);\r\n        }\r\n      }, 500);\r\n    } else {\r\n      setIsCheckingUsername(false);\r\n    }\r\n  };\r\n\r\n  const handleDisconnect = () => {\r\n    if (socketRef.current) {\r\n      socketRef.current.disconnect();\r\n    }\r\n    \r\n    setConnected(false);\r\n    setUsername('');\r\n    setMessages([]);\r\n    setStatus('Disconnected');\r\n    clearInterval(pingIntervalRef.current);\r\n    clearTimeout(recipientCheckTimeoutRef.current);\r\n    clearTimeout(typingTimeoutRef.current);\r\n  };\r\n\r\n  const connectToBaseNode = () => {\r\n    // Clear any previous connection\r\n    if (socketRef.current) {\r\n      socketRef.current.disconnect();\r\n    }\r\n    \r\n    // Always connect to base node first for handshake and relay discovery\r\n    console.log('Connecting to base node for initial handshake:', BASE_NODE_URL);\r\n    setStatus('Connecting to base node for handshake...');\r\n    \r\n    socketRef.current = io(BASE_NODE_URL, {\r\n      transports: ['websocket', 'polling'],\r\n      reconnectionAttempts: 3,\r\n      reconnectionDelay: 1000,\r\n      query: { \r\n        username,\r\n        deviceId,\r\n        publicKey: keyPair?.publicKey ? JSON.stringify(keyPair.publicKey) : null\r\n      },\r\n      auth: {\r\n        username,\r\n        deviceId\r\n      },\r\n      forceNew: true\r\n    });\r\n    \r\n    // Connection event handlers\r\n    socketRef.current.on('connect', () => {\r\n      console.log('Connected to base node with socket ID:', socketRef.current.id);\r\n      setStatus('Connected to base node for handshake');\r\n      setRelayStatus('online');\r\n      \r\n      // When connecting to the base node, set the relay information accordingly\r\n      setConnectionDetails({\r\n        socketId: socketRef.current.id,\r\n        transport: socketRef.current.io.engine.transport.name,\r\n        baseNodeUrl: BASE_NODE_URL,\r\n        relayStatus: 'direct_to_base'\r\n      });\r\n      \r\n      setRelayServerUrl('Base Node');\r\n      \r\n      // Register with the base node\r\n      socketRef.current.emit('register', { \r\n        username, \r\n        deviceId,\r\n        publicKey: keyPair?.publicKey\r\n      }, (response) => {\r\n        console.log('Registration response:', response);\r\n        \r\n        if (response && response.success) {\r\n          setStatus('Registered successfully');\r\n          \r\n          // Connect socket events\r\n          connectSocketEvents();\r\n          \r\n          // Start ping interval\r\n          startPingInterval();\r\n          \r\n          // Get available relays first\r\n          socketRef.current.emit('getAvailableRelays', {}, (response) => {\r\n            console.log('Available relays:', response);\r\n            \r\n            if (response && response.relays && response.relays.length > 0) {\r\n              // Cache relay information\r\n              localStorage.setItem('whispernetRelayCache', JSON.stringify({\r\n                timestamp: Date.now(),\r\n                relays: response.relays\r\n              }));\r\n              \r\n              // Connect to the first available relay\r\n              connectToRelay(response.relays[0]);\r\n            } else {\r\n              console.log('No relays available, using base node');\r\n              setStatus('No relay servers available, using base node');\r\n              \r\n              // Start polling for available relays\r\n              startRelayPolling();\r\n            }\r\n          });\r\n        } else {\r\n          console.error('Registration failed:', response?.reason || 'Unknown error');\r\n          setStatus(`Registration failed: ${response?.reason || 'Unknown error'}`);\r\n        }\r\n      });\r\n    });\r\n    \r\n    socketRef.current.on('connect_error', (err) => {\r\n      console.error('Base node connection error:', err);\r\n      setStatus(`Connection failed: ${err.message}`);\r\n      setRelayStatus('offline');\r\n      \r\n      // Try to use cached relays if available\r\n      try {\r\n        const cachedRelayInfo = localStorage.getItem('whispernetRelayCache');\r\n        if (cachedRelayInfo) {\r\n          const relayInfo = JSON.parse(cachedRelayInfo);\r\n          const cacheAge = Date.now() - relayInfo.timestamp;\r\n          \r\n          // Use cache if it's less than 1 hour old\r\n          if (cacheAge < 3600000 && relayInfo.relays && relayInfo.relays.length > 0) {\r\n            console.log('Using cached relay information');\r\n            \r\n            // Try to connect to the first cached relay\r\n            connectToRelay(relayInfo.relays[0]);\r\n            return;\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error('Error parsing cached relay info:', error);\r\n      }\r\n    });\r\n    \r\n    socketRef.current.on('disconnect', (reason) => {\r\n      console.log('Disconnected from base node:', reason);\r\n      setStatus(`Disconnected: ${reason}`);\r\n      \r\n      // Don't auto-reconnect if user manually disconnected\r\n      if (reason !== 'io client disconnect' && connected) {\r\n        setStatus('Reconnecting...');\r\n        \r\n        // Try to reconnect after a delay\r\n        setTimeout(() => {\r\n          if (connected) {\r\n            connectToBaseNode();\r\n          }\r\n        }, 3000);\r\n      }\r\n    });\r\n  };\r\n\r\n  const connectToRelay = (relayInfo) => {\r\n    if (!relayInfo || !relayInfo.url) {\r\n      console.error('Invalid relay information');\r\n      return;\r\n    }\r\n    \r\n    const relayUrl = relayInfo.url;\r\n    console.log(`Connecting to relay server: ${relayUrl}`);\r\n    setStatus(`Connecting to relay server: ${relayUrl}`);\r\n    \r\n    // Keep a reference to the old socket\r\n    const oldSocket = socketRef.current;\r\n    \r\n    // Connect to the relay server\r\n    socketRef.current = io(relayUrl, {\r\n      transports: ['websocket', 'polling'],\r\n      reconnectionAttempts: 3,\r\n      reconnectionDelay: 1000,\r\n      query: { \r\n        username,\r\n        deviceId,\r\n        publicKey: keyPair?.publicKey ? JSON.stringify(keyPair.publicKey) : null\r\n      },\r\n      auth: {\r\n        username,\r\n        deviceId\r\n      },\r\n      forceNew: true\r\n    });\r\n    \r\n    // Set a timeout to disconnect from base node after relay connection is established\r\n    const relayConnectionTimeout = setTimeout(() => {\r\n      if (!socketRef.current || !socketRef.current.connected) {\r\n        console.log('Relay connection timed out, staying with base node');\r\n        socketRef.current = oldSocket; // Restore old socket\r\n        setStatus('Using Base Node (relay connection failed)');\r\n        setRelayServerUrl('Base Node (Fallback)');\r\n        setConnectionDetails(prev => ({\r\n          ...prev,\r\n          relayStatus: 'direct_to_base'\r\n        }));\r\n        \r\n        // Connect socket events if they weren't already connected\r\n        connectSocketEvents();\r\n        \r\n        // Start ping interval\r\n        startPingInterval();\r\n        \r\n        // Start polling for available relays\r\n        startRelayPolling();\r\n      }\r\n    }, 5000);\r\n    \r\n    socketRef.current.on('connect', () => {\r\n      clearTimeout(relayConnectionTimeout);\r\n      console.log(`Connected to relay server: ${relayUrl}`);\r\n      \r\n      // Register with the relay\r\n      socketRef.current.emit('register', { \r\n        username, \r\n        deviceId,\r\n        publicKey: keyPair?.publicKey\r\n      }, (response) => {\r\n        console.log('Relay registration response:', response);\r\n        \r\n        if (response && response.success) {\r\n          setStatus('Connected to relay server');\r\n          setRelayServerUrl(relayUrl);\r\n          \r\n          // Update connection details\r\n          setConnectionDetails({\r\n            socketId: socketRef.current.id,\r\n            transport: socketRef.current.io.engine.transport.name,\r\n            baseNodeUrl: BASE_NODE_URL,\r\n            relayStatus: 'connected_to_relay',\r\n            ip: relayInfo.ip,\r\n            port: relayInfo.port,\r\n            connectedUsers: relayInfo.connectedUsers\r\n          });\r\n          \r\n          // Disconnect from base node\r\n          if (oldSocket && oldSocket.connected) {\r\n            console.log('Disconnecting from base node');\r\n            oldSocket.disconnect();\r\n          }\r\n          \r\n          // Connect socket events\r\n          connectSocketEvents();\r\n          \r\n          // Start ping interval\r\n          startPingInterval();\r\n        } else {\r\n          console.error('Failed to register with relay:', response);\r\n          setStatus('Failed to register with relay server');\r\n          \r\n          // Disconnect from relay and stay with base node\r\n          socketRef.current.disconnect();\r\n          socketRef.current = oldSocket;\r\n          \r\n          setStatus('Using Base Node (relay registration failed)');\r\n          setRelayServerUrl('Base Node (Fallback)');\r\n          setConnectionDetails(prev => ({\r\n            ...prev,\r\n            relayStatus: 'direct_to_base'\r\n          }));\r\n          \r\n          // Connect socket events\r\n          connectSocketEvents();\r\n          \r\n          // Start ping interval\r\n          startPingInterval();\r\n          \r\n          // Start polling for available relays\r\n          startRelayPolling();\r\n        }\r\n      });\r\n    });\r\n    \r\n    socketRef.current.on('connect_error', (err) => {\r\n      clearTimeout(relayConnectionTimeout);\r\n      console.error(`Relay connection error: ${err.message}`);\r\n      \r\n      // Stay with base node\r\n      socketRef.current = oldSocket;\r\n      \r\n      setStatus('Using Base Node (relay connection failed)');\r\n      setRelayServerUrl('Base Node (Fallback)');\r\n      setConnectionDetails(prev => ({\r\n        ...prev,\r\n        relayStatus: 'direct_to_base'\r\n      }));\r\n      \r\n      // Connect socket events\r\n      connectSocketEvents();\r\n      \r\n      // Start ping interval\r\n      startPingInterval();\r\n      \r\n      // Start polling for available relays\r\n      startRelayPolling();\r\n    });\r\n    \r\n    socketRef.current.on('disconnect', (reason) => {\r\n      console.log(`Disconnected from relay: ${reason}`);\r\n      \r\n      // If we were previously connected to a relay and lost connection\r\n      if (connectionDetails.relayStatus === 'connected_to_relay') {\r\n        setStatus(`Disconnected from relay: ${reason}`);\r\n        \r\n        // Try to reconnect to base node\r\n        connectToBaseNode();\r\n      }\r\n    });\r\n  };\r\n\r\n  const startRelayPolling = () => {\r\n    // Clear any existing polling interval\r\n    if (window.relayPollingInterval) {\r\n      clearInterval(window.relayPollingInterval);\r\n    }\r\n    \r\n    // Set up polling interval\r\n    window.relayPollingInterval = setInterval(() => {\r\n      if (socketRef.current && socketRef.current.connected && \r\n          connectionDetails.relayStatus === 'direct_to_base') {\r\n        console.log('Polling for available relays...');\r\n        \r\n        socketRef.current.emit('getAvailableRelays', {}, (response) => {\r\n          if (response && response.relays && response.relays.length > 0) {\r\n            console.log('Found available relays:', response.relays);\r\n            \r\n            // Cache relay information\r\n            localStorage.setItem('whispernetRelayCache', JSON.stringify({\r\n              timestamp: Date.now(),\r\n              relays: response.relays\r\n            }));\r\n            \r\n            // Connect to the first available relay\r\n            connectToRelay(response.relays[0]);\r\n            \r\n            // Clear polling interval\r\n            clearInterval(window.relayPollingInterval);\r\n          } else {\r\n            console.log('No relays available, continuing to use base node');\r\n          }\r\n        });\r\n      }\r\n    }, 30000); // Poll every 30 seconds\r\n    \r\n    // Clean up on component unmount\r\n    return () => {\r\n      if (window.relayPollingInterval) {\r\n        clearInterval(window.relayPollingInterval);\r\n      }\r\n    };\r\n  };\r\n\r\n  const connectSocketEvents = () => {\r\n    // Message handling\r\n    socketRef.current.on('receiveMessage', async (data) => {\r\n      console.log('Received message:', data);\r\n      const { from, message, fromDeviceId, timestamp, encrypted, publicKey, bounced } = data;\r\n      \r\n      // Store sender's public key if provided\r\n      if (publicKey && from) {\r\n        console.log(`Storing public key for ${from}`);\r\n        setPublicKeys(prev => ({ ...prev, [from]: publicKey }));\r\n      }\r\n      \r\n      // Security check for device ID changes\r\n      const previousMessages = messages.filter(msg => msg.from === from);\r\n      if (previousMessages.length > 0 && previousMessages[0].fromDeviceId && \r\n          previousMessages[0].fromDeviceId !== fromDeviceId) {\r\n        setSecurityAlert({\r\n          username: from,\r\n          message: `Warning: ${from} appears to be messaging from a different device!`,\r\n          type: 'warning'\r\n        });\r\n      }\r\n      \r\n      let decryptedMessage = message;\r\n      let decryptionStatus = 'plaintext';\r\n      \r\n      // Decrypt the message if it's encrypted and we have our private key\r\n      if (encrypted && keyPair?.privateKey) {\r\n        try {\r\n          console.log('Decrypting message...');\r\n          decryptedMessage = await decryptMessage(message, keyPair.privateKey);\r\n          decryptionStatus = 'decrypted';\r\n          console.log('Message decrypted successfully');\r\n        } catch (error) {\r\n          console.error('Failed to decrypt message:', error);\r\n          decryptedMessage = '[Encrypted message - cannot decrypt]';\r\n          decryptionStatus = 'failed';\r\n          \r\n          setSecurityAlert({\r\n            username: 'System',\r\n            message: `Failed to decrypt message from ${from}. Your keys may have changed.`,\r\n            type: 'warning'\r\n          });\r\n        }\r\n      }\r\n      \r\n      // Create message object\r\n      const messageObj = { \r\n        from, \r\n        message: decryptedMessage, \r\n        fromDeviceId, \r\n        timestamp: new Date(timestamp || new Date()),\r\n        encrypted,\r\n        decryptionStatus,\r\n        bounced\r\n      };\r\n      \r\n      // Add to messages array for current view\r\n      setMessages(msgs => [...msgs, messageObj]);\r\n      \r\n      // Update chat history for this contact\r\n      updateChatHistory(from, messageObj);\r\n      \r\n      // Update trust status - mark that we received a message from this user\r\n      updateTrustStatus(from, { receivedMessage: true });\r\n    });\r\n    \r\n    // Handle public key requests\r\n    socketRef.current.on('publicKeyRequest', ({ from }, ack) => {\r\n      console.log(`Public key requested by ${from}`);\r\n      \r\n      if (keyPair && keyPair.publicKey) {\r\n        console.log(`Sending public key to ${from}`);\r\n        if (ack) ack({ success: true, publicKey: keyPair.publicKey });\r\n      } else {\r\n        console.warn('No public key available to share');\r\n        if (ack) ack({ success: false, reason: 'Public key not available' });\r\n      }\r\n    });\r\n    \r\n    // User status updates\r\n    socketRef.current.on('userStatusUpdate', (data) => {\r\n      console.log('User status update:', data);\r\n      const { username: user, online } = data;\r\n      \r\n      // If this is our current recipient, update their status\r\n      if (user === recipient) {\r\n        console.log(`Updating status for current recipient ${user} to ${online ? 'online' : 'offline'}`);\r\n        setRecipientStatus(prev => ({ \r\n          ...prev, \r\n          exists: true, // If we got a status update, the user definitely exists\r\n          online,\r\n          notRegisteredYet: false // Clear this flag since we know the user exists\r\n        }));\r\n      }\r\n      \r\n      // Update online users list\r\n      setOnlineUsers(prev => {\r\n        if (online && !prev.includes(user)) {\r\n          console.log(`Adding ${user} to online users list`);\r\n          return [...prev, user];\r\n        } else if (!online && prev.includes(user)) {\r\n          console.log(`Removing ${user} from online users list`);\r\n          return prev.filter(u => u !== user);\r\n        }\r\n        return prev;\r\n      });\r\n      \r\n      // If we have a recipient, check if they're in the online users list\r\n      if (recipient) {\r\n        checkRecipientStatus();\r\n      }\r\n    });\r\n    \r\n    // Handle bulk online users updates\r\n    socketRef.current.on('onlineUsersUpdate', (data) => {\r\n      console.log('Online users update:', data);\r\n      if (data && Array.isArray(data.users)) {\r\n        setOnlineUsers(data.users);\r\n        \r\n        // If we have a recipient, check if they're in the online users list\r\n        if (recipient) {\r\n          const isOnline = data.users.includes(recipient);\r\n          console.log(`Recipient ${recipient} is ${isOnline ? 'online' : 'offline'}`);\r\n          \r\n          setRecipientStatus(prev => ({ \r\n            ...prev, \r\n            exists: prev.exists, // Keep existing value\r\n            online: isOnline,\r\n            notRegisteredYet: false // Clear this flag since we got an update\r\n          }));\r\n        }\r\n      }\r\n    });\r\n    \r\n    // Typing indicators\r\n    socketRef.current.on('userTyping', (data) => {\r\n      const { username: typingUser } = data;\r\n      if (typingUser === recipient) {\r\n        setTyping(true);\r\n        clearTimeout(typingTimeoutRef.current);\r\n        typingTimeoutRef.current = setTimeout(() => setTyping(false), 3000);\r\n      }\r\n    });\r\n    \r\n    // Error handling\r\n    socketRef.current.on('error', (error) => {\r\n      console.error('Socket error:', error);\r\n      setSecurityAlert({\r\n        username: 'System',\r\n        message: `Connection error: ${error.message || 'Unknown error'}`,\r\n        type: 'error'\r\n      });\r\n    });\r\n    \r\n    // Request online users list\r\n    if (socketRef.current && socketRef.current.connected) {\r\n      socketRef.current.emit('getOnlineUsers', {}, (response) => {\r\n        if (response && Array.isArray(response.users)) {\r\n          console.log('Online users:', response.users);\r\n          setOnlineUsers(response.users);\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  const startPingInterval = () => {\r\n    pingIntervalRef.current = setInterval(() => {\r\n      if (socketRef.current && socketRef.current.connected) {\r\n        // Send ping to keep connection alive\r\n        socketRef.current.emit('ping', {}, (response) => {\r\n          if (response) {\r\n            console.log('Ping response:', response);\r\n          }\r\n        });\r\n        \r\n        // Request online users list\r\n        socketRef.current.emit('getOnlineUsers', {}, (response) => {\r\n          if (response && Array.isArray(response.users)) {\r\n            console.log('Online users:', response.users);\r\n            setOnlineUsers(response.users);\r\n          }\r\n        });\r\n      }\r\n    }, 30000); // Ping every 30 seconds\r\n  };\r\n\r\n  const checkRecipientStatus = () => {\r\n    if (!recipient || !socketRef.current || !socketRef.current.connected) {\r\n      return;\r\n    }\r\n    \r\n    console.log(`Checking status for recipient: ${recipient}`);\r\n    \r\n    // Check if the recipient is in the online users list\r\n    const isOnline = onlineUsers.includes(recipient);\r\n    \r\n    // Check if the user exists\r\n    socketRef.current.emit('checkUser', { username: recipient }, (response) => {\r\n      console.log('Check user response:', response);\r\n      \r\n      if (response && response.exists) {\r\n        setRecipientStatus({ \r\n          exists: true, \r\n          online: isOnline,\r\n          notRegisteredYet: false\r\n        });\r\n      } else {\r\n        setRecipientStatus({ \r\n          exists: false, \r\n          online: false,\r\n          notRegisteredYet: true\r\n        });\r\n      }\r\n    });\r\n  };\r\n\r\n  const handleRecipientChange = (e) => {\r\n    const newRecipient = e.target.value.trim();\r\n    setRecipient(newRecipient);\r\n    \r\n    if (newRecipient) {\r\n      // Use a small delay to avoid too many checks while typing\r\n      if (recipientCheckTimeoutRef.current) {\r\n        clearTimeout(recipientCheckTimeoutRef.current);\r\n      }\r\n      \r\n      recipientCheckTimeoutRef.current = setTimeout(() => {\r\n        checkRecipientStatus();\r\n      }, 500); // 500ms delay\r\n    }\r\n  };\r\n\r\n  const handleSend = async (e, bounce = false) => {\r\n    e.preventDefault();\r\n    if (!recipient || !message.trim() || !socketRef.current) return;\r\n    \r\n    try {\r\n      // Show sending indicator\r\n      setStatus('Sending message...');\r\n      \r\n      // If this is a relay/bounce message, we'll proceed regardless of recipient status\r\n      if (!bounce) {\r\n        // For direct messages, we need to check if the recipient exists and is online\r\n        const recipientOnline = recipientStatus.online;\r\n        \r\n        // If recipient is not online, suggest using relay\r\n        if (!recipientOnline) {\r\n          setSecurityAlert({\r\n            username: 'System',\r\n            message: `${recipient} is offline or not found. Use the RELAY button to send a delayed message.`,\r\n            type: 'warning'\r\n          });\r\n          setStatus('Registered successfully');\r\n          return;\r\n        }\r\n      }\r\n      \r\n      // Get recipient's public key if we don't have it and encryption is enabled\r\n      if (encryptionEnabled && !publicKeys[recipient]) {\r\n        try {\r\n          await requestPublicKey(recipient);\r\n        } catch (error) {\r\n          console.error('Failed to get public key:', error);\r\n          // Continue without encryption if we can't get the key\r\n        }\r\n      }\r\n      \r\n      let finalMessage = message.trim();\r\n      let isEncrypted = false;\r\n      \r\n      // Encrypt the message if encryption is enabled and we have the recipient's public key\r\n      if (encryptionEnabled && publicKeys[recipient]) {\r\n        try {\r\n          finalMessage = await encryptMessage(message.trim(), publicKeys[recipient]);\r\n          isEncrypted = true;\r\n          console.log('Message encrypted successfully');\r\n        } catch (error) {\r\n          console.error('Failed to encrypt message:', error);\r\n          setSecurityAlert({\r\n            username: 'System',\r\n            message: 'Failed to encrypt message. Sending as plaintext.',\r\n            type: 'warning'\r\n          });\r\n        }\r\n      }\r\n      \r\n      const messageData = {\r\n        to: recipient,\r\n        message: finalMessage,\r\n        deviceId,\r\n        timestamp: new Date().toISOString(),\r\n        bounce: bounce, // Always use the bounce parameter directly\r\n        encrypted: isEncrypted,\r\n        publicKey: keyPair?.publicKey // Send our public key with the message\r\n      };\r\n      \r\n      console.log('Sending message:', { \r\n        ...messageData, \r\n        message: isEncrypted ? '[ENCRYPTED]' : finalMessage,\r\n        bounce: bounce\r\n      });\r\n      \r\n      // Add a timeout to handle cases where the server doesn't respond\r\n      const messageTimeout = setTimeout(() => {\r\n        setSecurityAlert({\r\n          username: 'System',\r\n          message: 'Message sending timed out. Server may be offline.',\r\n          type: 'error'\r\n        });\r\n        setStatus('Registered successfully');\r\n      }, 10000);\r\n      \r\n      socketRef.current.emit('sendMessage', messageData, (response) => {\r\n        clearTimeout(messageTimeout);\r\n        console.log('Send message response:', response);\r\n        setStatus('Registered successfully');\r\n        \r\n        if (response && (response.delivered || response.bounced)) {\r\n          // Create message object\r\n          const messageObj = { \r\n            from: username, \r\n            message: message.trim(), // Store original message for display\r\n            fromDeviceId: deviceId, \r\n            timestamp: new Date(),\r\n            status: response.delivered ? 'delivered' : 'bounced',\r\n            expiresAt: response.expiresAt,\r\n            encrypted: isEncrypted\r\n          };\r\n          \r\n          // Add message to local state (store original message for display)\r\n          setMessages(msgs => [...msgs, messageObj]);\r\n          \r\n          // Update chat history for this contact\r\n          updateChatHistory(recipient, messageObj);\r\n          \r\n          // Update trust status - mark that we sent a message to this user\r\n          updateTrustStatus(recipient, { sentMessage: true });\r\n          \r\n          setMessage('');\r\n          \r\n          // Show notification if message was bounced\r\n          if (response.bounced) {\r\n            setSecurityAlert({\r\n              username: 'System',\r\n              message: `Message to ${recipient} will be delivered when they come online (expires in 4 hours)`,\r\n              type: 'info'\r\n            });\r\n          }\r\n        } else {\r\n          const errorMsg = response?.reason || 'Message delivery failed';\r\n          \r\n          if (errorMsg.includes('not found') || errorMsg.includes('User not found')) {\r\n            if (bounce) {\r\n              // For bounced messages to non-existent users, show a special message\r\n              setSecurityAlert({\r\n                username: 'System',\r\n                message: `Message will be delivered if ${recipient} registers within 4 hours.`,\r\n                type: 'info'\r\n              });\r\n              \r\n              // Create message object\r\n              const messageObj = { \r\n                from: username, \r\n                message: message.trim(),\r\n                fromDeviceId: deviceId, \r\n                timestamp: new Date(),\r\n                status: 'bounced',\r\n                expiresAt: Date.now() + 14400000, // 4 hours\r\n                encrypted: isEncrypted\r\n              };\r\n              \r\n              // Add message to local state as bounced\r\n              setMessages(msgs => [...msgs, messageObj]);\r\n              \r\n              // Update chat history for this contact\r\n              updateChatHistory(recipient, messageObj);\r\n              \r\n              // Update trust status - mark that we sent a message to this user\r\n              updateTrustStatus(recipient, { sentMessage: true });\r\n              \r\n              setMessage('');\r\n            } else {\r\n              setSecurityAlert({\r\n                username: 'System',\r\n                message: `${recipient} not found. Use the RELAY button to send a message that will be delivered if they register.`,\r\n                type: 'warning'\r\n              });\r\n            }\r\n          } else if (errorMsg.includes('offline')) {\r\n            setSecurityAlert({\r\n              username: 'System',\r\n              message: `${recipient} is offline. Use the RELAY button to send a delayed message.`,\r\n              type: 'warning'\r\n            });\r\n          } else {\r\n            setSecurityAlert({\r\n              username: 'System',\r\n              message: `Failed to send message: ${errorMsg}`,\r\n              type: 'error'\r\n            });\r\n          }\r\n        }\r\n      });\r\n    } catch (error) {\r\n      console.error('Error sending message:', error);\r\n      setSecurityAlert({\r\n        username: 'System',\r\n        message: `Error sending message: ${error.message}`,\r\n        type: 'error'\r\n      });\r\n      setStatus('Registered successfully');\r\n    }\r\n  };\r\n  \r\n  // Request public key from a user\r\n  const requestPublicKey = async (username) => {\r\n    return new Promise((resolve, reject) => {\r\n      if (!socketRef.current) {\r\n        reject(new Error('Not connected'));\r\n        return;\r\n      }\r\n      \r\n      console.log(`Requesting public key for ${username}...`);\r\n      \r\n      // Set a timeout in case the server doesn't respond\r\n      const requestTimeout = setTimeout(() => {\r\n        console.error(`Public key request for ${username} timed out`);\r\n        reject(new Error('Request timed out'));\r\n      }, 10000);\r\n      \r\n      socketRef.current.emit('requestPublicKey', { username }, (response) => {\r\n        clearTimeout(requestTimeout);\r\n        \r\n        if (response && response.success && response.publicKey) {\r\n          console.log(`Received public key for ${username}`);\r\n          setPublicKeys(prev => ({ ...prev, [username]: response.publicKey }));\r\n          resolve(response.publicKey);\r\n        } else {\r\n          const reason = response?.reason || 'Public key not available';\r\n          console.log(`No public key available for ${username}: ${reason}`);\r\n          reject(new Error(reason));\r\n        }\r\n      });\r\n    });\r\n  };\r\n  \r\n  const handleBounce = (e) => {\r\n    if (!recipient || !message.trim()) {\r\n      return;\r\n    }\r\n    \r\n    // Show confirmation before bouncing\r\n    const confirmBounce = window.confirm(\r\n      `RELAY MESSAGE\\n\\n` +\r\n      `Your message to \"${recipient}\" will be stored on ${connectionDetails.relayStatus === 'connected_to_relay' ? 'relay' : 'base node'} servers for up to 4 hours.\\n\\n` +\r\n      `It will be delivered when ${recipient} comes online or registers with the network.\\n\\n` +\r\n      `Continue?`\r\n    );\r\n    \r\n    if (confirmBounce) {\r\n      handleSend(e, true);\r\n    }\r\n  };\r\n\r\n  const handleMessageChange = (e) => {\r\n    setMessage(e.target.value);\r\n    \r\n    // Send typing indicator\r\n    if (socketRef.current && recipient && e.target.value.length > 0) {\r\n      socketRef.current.emit('typing', { to: recipient });\r\n    }\r\n  };\r\n\r\n  const dismissAlert = () => {\r\n    setSecurityAlert(null);\r\n  };\r\n\r\n  const retryConnection = () => {\r\n    checkRelayStatus();\r\n  };\r\n\r\n  // Utility functions\r\n  const getTimestamp = () => {\r\n    const now = new Date();\r\n    return `[${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}]`;\r\n  };\r\n\r\n  const formatMessageTime = (timestamp) => {\r\n    if (!timestamp) return getTimestamp();\r\n    const date = new Date(timestamp);\r\n    return `[${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}]`;\r\n  };\r\n  \r\n  // Function to switch to a specific chat\r\n  const switchToChat = (contactUsername) => {\r\n    setActiveChat(contactUsername);\r\n    setRecipient(contactUsername || '');\r\n    \r\n    // Load messages for this contact\r\n    if (contactUsername && chatHistory[contactUsername]) {\r\n      setMessages(chatHistory[contactUsername]);\r\n    } else {\r\n      setMessages([]);\r\n    }\r\n    \r\n    // Check if we need to show trust warning\r\n    if (contactUsername && trustStatus[contactUsername]) {\r\n      setShowTrustWarning(!trustStatus[contactUsername].mutualMessaging);\r\n    } else if (contactUsername) {\r\n      setShowTrustWarning(true);\r\n    } else {\r\n      setShowTrustWarning(false);\r\n    }\r\n  };\r\n  \r\n  // Function to toggle About page\r\n  const toggleAboutPage = () => {\r\n    setShowAboutPage(!showAboutPage);\r\n  };\r\n\r\n  return (\r\n    <div style={{ \r\n      background: '#0a0e14', \r\n      minHeight: '100vh', \r\n      color: '#a2aabc', \r\n      display: 'flex',\r\n      flexDirection: 'column',\r\n      fontFamily: '\"Fira Code\", monospace'\r\n    }}>\r\n      {/* Header */}\r\n      <header style={{\r\n        background: '#171c28',\r\n        padding: '16px 24px',\r\n        borderBottom: '1px solid rgba(0, 255, 170, 0.3)',\r\n        display: 'flex',\r\n        justifyContent: 'space-between',\r\n        alignItems: 'center'\r\n      }}>\r\n        <div style={{ display: 'flex', alignItems: 'center' }}>\r\n          <h1 style={{ \r\n            margin: 0, \r\n            color: '#5ccfe6', \r\n            fontFamily: '\"Fira Code\", monospace',\r\n            letterSpacing: '1px',\r\n            fontSize: '24px'\r\n          }}>WhisperNet_</h1>\r\n          \r\n          {username && (\r\n            <span style={{ \r\n              marginLeft: '16px', \r\n              color: '#bae67e', \r\n              fontSize: '14px',\r\n              padding: '4px 8px',\r\n              background: 'rgba(186, 230, 126, 0.1)',\r\n              borderRadius: '4px'\r\n            }}>\r\n              @{username}\r\n            </span>\r\n          )}\r\n        </div>\r\n        \r\n        <div style={{ display: 'flex', alignItems: 'center' }}>\r\n          <div style={{ \r\n            fontSize: 12, \r\n            padding: '4px 8px', \r\n            borderRadius: 4, \r\n            background: relayStatus === 'online' ? '#1c4b3c' : '#4b1c1c',\r\n            color: relayStatus === 'online' ? '#5ccfe6' : '#ff8f40',\r\n            cursor: 'pointer',\r\n            marginRight: '12px'\r\n          }} onClick={() => setShowConnectionInfo(!showConnectionInfo)}>\r\n            {relayStatus === 'online' ? 'Base Node Online' : \r\n             relayStatus === 'checking' ? 'Checking...' : 'Base Node Offline'}\r\n          </div>\r\n          \r\n          {connected && (\r\n            <button \r\n              style={{ \r\n                padding: '8px 16px', \r\n                borderRadius: 4, \r\n                background: '#4b1c1c', \r\n                color: '#ff8f40', \r\n                fontSize: 14, \r\n                border: 'none',\r\n                cursor: 'pointer',\r\n                fontFamily: '\"Fira Code\", monospace',\r\n                marginRight: '12px'\r\n              }} \r\n              onClick={handleDisconnect}\r\n            >\r\n              DISCONNECT\r\n            </button>\r\n          )}\r\n          \r\n          <button \r\n            style={{ \r\n              padding: '8px 16px', \r\n              borderRadius: 4, \r\n              background: '#1c3b4b', \r\n              color: '#5ccfe6', \r\n              fontSize: 14, \r\n              border: 'none',\r\n              cursor: 'pointer',\r\n              fontFamily: '\"Fira Code\", monospace'\r\n            }} \r\n            onClick={toggleAboutPage}\r\n          >\r\n            {showAboutPage ? 'BACK TO CHAT' : 'ABOUT'}\r\n          </button>\r\n        </div>\r\n      </header>\r\n      \r\n      {/* Connection info */}\r\n      {showConnectionInfo && (\r\n        <div style={{ padding: '0 24px' }}>\r\n          <ConnectionInfo\r\n            status={status}\r\n            connected={connected}\r\n            connectionDetails={connectionDetails}\r\n            relayServerUrl={relayServerUrl}\r\n            relayStatus={relayStatus}\r\n            deviceId={deviceId}\r\n            BASE_NODE_URL={BASE_NODE_URL}\r\n          />\r\n        </div>\r\n      )}\r\n      \r\n      {/* Security alert */}\r\n      {securityAlert && (\r\n        <div style={{ padding: '0 24px' }}>\r\n          <SecurityAlert alert={securityAlert} onDismiss={dismissAlert} />\r\n        </div>\r\n      )}\r\n      \r\n      {/* Main content */}\r\n      <div style={{ \r\n        flex: 1,\r\n        display: 'flex',\r\n        height: 'calc(100vh - 69px - (showConnectionInfo ? 80 : 0) - (securityAlert ? 60 : 0))' // Subtract header height and optional elements\r\n      }}>\r\n        {showAboutPage ? (\r\n          <AboutPage />\r\n        ) : !connected ? (\r\n          <LoginScreen\r\n            username={username}\r\n            handleUsernameChange={handleUsernameChange}\r\n            handleUsernameSubmit={handleUsernameSubmit}\r\n            isCheckingUsername={isCheckingUsername}\r\n            usernameAvailable={usernameAvailable}\r\n            relayStatus={relayStatus}\r\n            status={status}\r\n            securityAlert={securityAlert}\r\n            dismissAlert={dismissAlert}\r\n            retryConnection={retryConnection}\r\n            getTimestamp={getTimestamp}\r\n          />\r\n        ) : (\r\n          <ChatInterface\r\n            contacts={contacts}\r\n            activeChat={activeChat}\r\n            switchToChat={switchToChat}\r\n            onlineUsers={onlineUsers}\r\n            trustStatus={trustStatus}\r\n            recipient={recipient}\r\n            handleRecipientChange={handleRecipientChange}\r\n            message={message}\r\n            handleMessageChange={handleMessageChange}\r\n            handleSend={handleSend}\r\n            handleBounce={handleBounce}\r\n            recipientStatus={recipientStatus}\r\n            messages={messages}\r\n            username={username}\r\n            typing={typing}\r\n            messagesEndRef={messagesEndRef}\r\n            formatMessageTime={formatMessageTime}\r\n            getTimestamp={getTimestamp}\r\n            showTrustWarning={showTrustWarning}\r\n          />\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}