{"ast":null,"code":"/**\n * WhisperNet Encryption Utilities\n * Provides end-to-end encryption for secure messaging\n */\n\n// We'll use the Web Crypto API for strong encryption\nconst generateKeyPair = async () => {\n  try {\n    const keyPair = await window.crypto.subtle.generateKey({\n      name: \"ECDH\",\n      namedCurve: \"P-256\"\n    }, true, [\"deriveKey\", \"deriveBits\"]);\n\n    // Export the public key for sharing\n    const publicKeyExported = await window.crypto.subtle.exportKey(\"spki\", keyPair.publicKey);\n\n    // Convert to base64 for easier transmission\n    const publicKeyBase64 = btoa(String.fromCharCode(...new Uint8Array(publicKeyExported)));\n    return {\n      keyPair,\n      publicKeyBase64\n    };\n  } catch (error) {\n    console.error('Error generating key pair:', error);\n    throw error;\n  }\n};\n\n// Import a public key from base64 format\nconst importPublicKey = async publicKeyBase64 => {\n  try {\n    const binaryString = atob(publicKeyBase64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return await window.crypto.subtle.importKey(\"spki\", bytes.buffer, {\n      name: \"ECDH\",\n      namedCurve: \"P-256\"\n    }, true, []);\n  } catch (error) {\n    console.error('Error importing public key:', error);\n    throw error;\n  }\n};\n\n// Derive a shared secret from our private key and their public key\nconst deriveSharedSecret = async (privateKey, publicKey) => {\n  try {\n    return await window.crypto.subtle.deriveBits({\n      name: \"ECDH\",\n      public: publicKey\n    }, privateKey, 256);\n  } catch (error) {\n    console.error('Error deriving shared secret:', error);\n    throw error;\n  }\n};\n\n// Generate an AES key from the shared secret\nconst deriveEncryptionKey = async sharedSecret => {\n  try {\n    const keyMaterial = await window.crypto.subtle.importKey(\"raw\", sharedSecret, {\n      name: \"PBKDF2\"\n    }, false, [\"deriveBits\", \"deriveKey\"]);\n    return await window.crypto.subtle.deriveKey({\n      name: \"PBKDF2\",\n      salt: new TextEncoder().encode(\"WhisperNetSalt\"),\n      iterations: 100000,\n      hash: \"SHA-256\"\n    }, keyMaterial, {\n      name: \"AES-GCM\",\n      length: 256\n    }, true, [\"encrypt\", \"decrypt\"]);\n  } catch (error) {\n    console.error('Error deriving encryption key:', error);\n    throw error;\n  }\n};\n\n// Encrypt a message using the derived key\nconst encryptMessage = async (message, encryptionKey) => {\n  try {\n    const iv = window.crypto.getRandomValues(new Uint8Array(12));\n    const encodedMessage = new TextEncoder().encode(message);\n    const encryptedData = await window.crypto.subtle.encrypt({\n      name: \"AES-GCM\",\n      iv\n    }, encryptionKey, encodedMessage);\n\n    // Convert to base64 for transmission\n    const encryptedBase64 = btoa(String.fromCharCode(...new Uint8Array(encryptedData)));\n    const ivBase64 = btoa(String.fromCharCode(...iv));\n    return {\n      encryptedData: encryptedBase64,\n      iv: ivBase64\n    };\n  } catch (error) {\n    console.error('Error encrypting message:', error);\n    throw error;\n  }\n};\n\n// Decrypt a message using the derived key\nconst decryptMessage = async (encryptedBase64, ivBase64, encryptionKey) => {\n  try {\n    // Convert from base64\n    const binaryEncrypted = atob(encryptedBase64);\n    const encryptedBytes = new Uint8Array(binaryEncrypted.length);\n    for (let i = 0; i < binaryEncrypted.length; i++) {\n      encryptedBytes[i] = binaryEncrypted.charCodeAt(i);\n    }\n    const binaryIv = atob(ivBase64);\n    const ivBytes = new Uint8Array(binaryIv.length);\n    for (let i = 0; i < binaryIv.length; i++) {\n      ivBytes[i] = binaryIv.charCodeAt(i);\n    }\n    const decryptedData = await window.crypto.subtle.decrypt({\n      name: \"AES-GCM\",\n      iv: ivBytes\n    }, encryptionKey, encryptedBytes);\n    return new TextDecoder().decode(decryptedData);\n  } catch (error) {\n    console.error('Error decrypting message:', error);\n    throw error;\n  }\n};\n\n// Generate a device-specific encryption key based on device fingerprint\nconst generateDeviceKey = async deviceId => {\n  try {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(deviceId);\n    const hash = await window.crypto.subtle.digest('SHA-256', data);\n    return await window.crypto.subtle.importKey(\"raw\", hash, {\n      name: \"AES-GCM\"\n    }, false, [\"encrypt\", \"decrypt\"]);\n  } catch (error) {\n    console.error('Error generating device key:', error);\n    throw error;\n  }\n};\n\n// Create a simple shared key for users who haven't exchanged public keys yet\n// This is less secure but allows for initial communication\nconst createTemporarySharedKey = async (username1, username2, deviceId) => {\n  try {\n    // Sort usernames to ensure the same key regardless of who initiates\n    const sortedNames = [username1, username2].sort().join('_');\n    const encoder = new TextEncoder();\n    const data = encoder.encode(sortedNames + '_' + deviceId);\n    const hash = await window.crypto.subtle.digest('SHA-256', data);\n    return await window.crypto.subtle.importKey(\"raw\", hash, {\n      name: \"AES-GCM\"\n    }, false, [\"encrypt\", \"decrypt\"]);\n  } catch (error) {\n    console.error('Error creating temporary shared key:', error);\n    throw error;\n  }\n};\n\n// Fallback encryption using a simple XOR cipher for environments without Web Crypto API\nconst fallbackEncrypt = (message, key) => {\n  let result = '';\n  for (let i = 0; i < message.length; i++) {\n    result += String.fromCharCode(message.charCodeAt(i) ^ key.charCodeAt(i % key.length));\n  }\n  return btoa(result); // Convert to base64\n};\n\n// Fallback decryption\nconst fallbackDecrypt = (encryptedBase64, key) => {\n  try {\n    const encrypted = atob(encryptedBase64); // Convert from base64\n    let result = '';\n    for (let i = 0; i < encrypted.length; i++) {\n      result += String.fromCharCode(encrypted.charCodeAt(i) ^ key.charCodeAt(i % key.length));\n    }\n    return result;\n  } catch (error) {\n    console.error('Error in fallback decryption:', error);\n    return '[Decryption Failed]';\n  }\n};\n\n// Check if Web Crypto API is available\nconst isWebCryptoSupported = () => {\n  return typeof window !== 'undefined' && window.crypto && window.crypto.subtle && typeof window.crypto.subtle.generateKey === 'function';\n};\nexport { generateKeyPair, importPublicKey, deriveSharedSecret, deriveEncryptionKey, encryptMessage, decryptMessage, generateDeviceKey, createTemporarySharedKey, fallbackEncrypt, fallbackDecrypt, isWebCryptoSupported };","map":{"version":3,"names":["generateKeyPair","keyPair","window","crypto","subtle","generateKey","name","namedCurve","publicKeyExported","exportKey","publicKey","publicKeyBase64","btoa","String","fromCharCode","Uint8Array","error","console","importPublicKey","binaryString","atob","bytes","length","i","charCodeAt","importKey","buffer","deriveSharedSecret","privateKey","deriveBits","public","deriveEncryptionKey","sharedSecret","keyMaterial","deriveKey","salt","TextEncoder","encode","iterations","hash","encryptMessage","message","encryptionKey","iv","getRandomValues","encodedMessage","encryptedData","encrypt","encryptedBase64","ivBase64","decryptMessage","binaryEncrypted","encryptedBytes","binaryIv","ivBytes","decryptedData","decrypt","TextDecoder","decode","generateDeviceKey","deviceId","encoder","data","digest","createTemporarySharedKey","username1","username2","sortedNames","sort","join","fallbackEncrypt","key","result","fallbackDecrypt","encrypted","isWebCryptoSupported"],"sources":["C:/Users/siddharth/Documents/GitHub/WhisperNet/frontend/src/encryptionUtils.js"],"sourcesContent":["/**\n * WhisperNet Encryption Utilities\n * Provides end-to-end encryption for secure messaging\n */\n\n// We'll use the Web Crypto API for strong encryption\nconst generateKeyPair = async () => {\n  try {\n    const keyPair = await window.crypto.subtle.generateKey(\n      {\n        name: \"ECDH\",\n        namedCurve: \"P-256\",\n      },\n      true,\n      [\"deriveKey\", \"deriveBits\"]\n    );\n    \n    // Export the public key for sharing\n    const publicKeyExported = await window.crypto.subtle.exportKey(\n      \"spki\",\n      keyPair.publicKey\n    );\n    \n    // Convert to base64 for easier transmission\n    const publicKeyBase64 = btoa(String.fromCharCode(...new Uint8Array(publicKeyExported)));\n    \n    return {\n      keyPair,\n      publicKeyBase64\n    };\n  } catch (error) {\n    console.error('Error generating key pair:', error);\n    throw error;\n  }\n};\n\n// Import a public key from base64 format\nconst importPublicKey = async (publicKeyBase64) => {\n  try {\n    const binaryString = atob(publicKeyBase64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    \n    return await window.crypto.subtle.importKey(\n      \"spki\",\n      bytes.buffer,\n      {\n        name: \"ECDH\",\n        namedCurve: \"P-256\",\n      },\n      true,\n      []\n    );\n  } catch (error) {\n    console.error('Error importing public key:', error);\n    throw error;\n  }\n};\n\n// Derive a shared secret from our private key and their public key\nconst deriveSharedSecret = async (privateKey, publicKey) => {\n  try {\n    return await window.crypto.subtle.deriveBits(\n      {\n        name: \"ECDH\",\n        public: publicKey\n      },\n      privateKey,\n      256\n    );\n  } catch (error) {\n    console.error('Error deriving shared secret:', error);\n    throw error;\n  }\n};\n\n// Generate an AES key from the shared secret\nconst deriveEncryptionKey = async (sharedSecret) => {\n  try {\n    const keyMaterial = await window.crypto.subtle.importKey(\n      \"raw\",\n      sharedSecret,\n      { name: \"PBKDF2\" },\n      false,\n      [\"deriveBits\", \"deriveKey\"]\n    );\n    \n    return await window.crypto.subtle.deriveKey(\n      {\n        name: \"PBKDF2\",\n        salt: new TextEncoder().encode(\"WhisperNetSalt\"),\n        iterations: 100000,\n        hash: \"SHA-256\"\n      },\n      keyMaterial,\n      { name: \"AES-GCM\", length: 256 },\n      true,\n      [\"encrypt\", \"decrypt\"]\n    );\n  } catch (error) {\n    console.error('Error deriving encryption key:', error);\n    throw error;\n  }\n};\n\n// Encrypt a message using the derived key\nconst encryptMessage = async (message, encryptionKey) => {\n  try {\n    const iv = window.crypto.getRandomValues(new Uint8Array(12));\n    const encodedMessage = new TextEncoder().encode(message);\n    \n    const encryptedData = await window.crypto.subtle.encrypt(\n      {\n        name: \"AES-GCM\",\n        iv\n      },\n      encryptionKey,\n      encodedMessage\n    );\n    \n    // Convert to base64 for transmission\n    const encryptedBase64 = btoa(String.fromCharCode(...new Uint8Array(encryptedData)));\n    const ivBase64 = btoa(String.fromCharCode(...iv));\n    \n    return {\n      encryptedData: encryptedBase64,\n      iv: ivBase64\n    };\n  } catch (error) {\n    console.error('Error encrypting message:', error);\n    throw error;\n  }\n};\n\n// Decrypt a message using the derived key\nconst decryptMessage = async (encryptedBase64, ivBase64, encryptionKey) => {\n  try {\n    // Convert from base64\n    const binaryEncrypted = atob(encryptedBase64);\n    const encryptedBytes = new Uint8Array(binaryEncrypted.length);\n    for (let i = 0; i < binaryEncrypted.length; i++) {\n      encryptedBytes[i] = binaryEncrypted.charCodeAt(i);\n    }\n    \n    const binaryIv = atob(ivBase64);\n    const ivBytes = new Uint8Array(binaryIv.length);\n    for (let i = 0; i < binaryIv.length; i++) {\n      ivBytes[i] = binaryIv.charCodeAt(i);\n    }\n    \n    const decryptedData = await window.crypto.subtle.decrypt(\n      {\n        name: \"AES-GCM\",\n        iv: ivBytes\n      },\n      encryptionKey,\n      encryptedBytes\n    );\n    \n    return new TextDecoder().decode(decryptedData);\n  } catch (error) {\n    console.error('Error decrypting message:', error);\n    throw error;\n  }\n};\n\n// Generate a device-specific encryption key based on device fingerprint\nconst generateDeviceKey = async (deviceId) => {\n  try {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(deviceId);\n    \n    const hash = await window.crypto.subtle.digest('SHA-256', data);\n    \n    return await window.crypto.subtle.importKey(\n      \"raw\",\n      hash,\n      { name: \"AES-GCM\" },\n      false,\n      [\"encrypt\", \"decrypt\"]\n    );\n  } catch (error) {\n    console.error('Error generating device key:', error);\n    throw error;\n  }\n};\n\n// Create a simple shared key for users who haven't exchanged public keys yet\n// This is less secure but allows for initial communication\nconst createTemporarySharedKey = async (username1, username2, deviceId) => {\n  try {\n    // Sort usernames to ensure the same key regardless of who initiates\n    const sortedNames = [username1, username2].sort().join('_');\n    const encoder = new TextEncoder();\n    const data = encoder.encode(sortedNames + '_' + deviceId);\n    \n    const hash = await window.crypto.subtle.digest('SHA-256', data);\n    \n    return await window.crypto.subtle.importKey(\n      \"raw\",\n      hash,\n      { name: \"AES-GCM\" },\n      false,\n      [\"encrypt\", \"decrypt\"]\n    );\n  } catch (error) {\n    console.error('Error creating temporary shared key:', error);\n    throw error;\n  }\n};\n\n// Fallback encryption using a simple XOR cipher for environments without Web Crypto API\nconst fallbackEncrypt = (message, key) => {\n  let result = '';\n  for (let i = 0; i < message.length; i++) {\n    result += String.fromCharCode(message.charCodeAt(i) ^ key.charCodeAt(i % key.length));\n  }\n  return btoa(result); // Convert to base64\n};\n\n// Fallback decryption\nconst fallbackDecrypt = (encryptedBase64, key) => {\n  try {\n    const encrypted = atob(encryptedBase64); // Convert from base64\n    let result = '';\n    for (let i = 0; i < encrypted.length; i++) {\n      result += String.fromCharCode(encrypted.charCodeAt(i) ^ key.charCodeAt(i % key.length));\n    }\n    return result;\n  } catch (error) {\n    console.error('Error in fallback decryption:', error);\n    return '[Decryption Failed]';\n  }\n};\n\n// Check if Web Crypto API is available\nconst isWebCryptoSupported = () => {\n  return typeof window !== 'undefined' && \n         window.crypto && \n         window.crypto.subtle && \n         typeof window.crypto.subtle.generateKey === 'function';\n};\n\nexport {\n  generateKeyPair,\n  importPublicKey,\n  deriveSharedSecret,\n  deriveEncryptionKey,\n  encryptMessage,\n  decryptMessage,\n  generateDeviceKey,\n  createTemporarySharedKey,\n  fallbackEncrypt,\n  fallbackDecrypt,\n  isWebCryptoSupported\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}