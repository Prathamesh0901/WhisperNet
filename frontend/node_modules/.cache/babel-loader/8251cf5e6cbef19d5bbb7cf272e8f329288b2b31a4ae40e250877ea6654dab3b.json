{"ast":null,"code":"/**\n * WhisperNet Message Utilities\n * Handles message persistence, offline relay, and message tracking\n */\n\n// Generate a unique message ID\nconst generateMessageId = () => {\n  return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);\n};\n\n// Calculate message TTL (Time To Live) in milliseconds\n// Default: 4 hours = 14400000 ms\nconst calculateMessageTTL = (hours = 4) => {\n  return Date.now() + hours * 60 * 60 * 1000;\n};\n\n// Alias for calculateMessageTTL for backward compatibility\nconst calculateTTL = calculateMessageTTL;\n\n// Check if a message has expired\nconst isMessageExpired = ttl => {\n  return Date.now() > ttl;\n};\n\n// Create a relay message with all necessary metadata\nconst createRelayMessage = (from, to, content, deviceId, encryptedContent, iv) => {\n  return {\n    id: generateMessageId(),\n    from,\n    to,\n    content: content || null,\n    // Plain content (if not encrypted)\n    fromDeviceId: deviceId,\n    timestamp: new Date().toISOString(),\n    ttl: calculateMessageTTL(),\n    encrypted: !!encryptedContent,\n    encryptedContent,\n    iv,\n    delivered: false,\n    bounceCount: 0,\n    maxBounces: 10 // Maximum number of relay hops\n  };\n};\n\n// Store pending messages locally\nconst storePendingMessage = message => {\n  try {\n    const pendingMessages = getPendingMessages();\n    pendingMessages.push(message);\n    localStorage.setItem('whisperNetPendingMessages', JSON.stringify(pendingMessages));\n    return true;\n  } catch (error) {\n    console.error('Error storing pending message:', error);\n    return false;\n  }\n};\n\n// Get all pending messages\nconst getPendingMessages = () => {\n  try {\n    const messages = localStorage.getItem('whisperNetPendingMessages');\n    return messages ? JSON.parse(messages) : [];\n  } catch (error) {\n    console.error('Error retrieving pending messages:', error);\n    return [];\n  }\n};\n\n// Remove a pending message by ID\nconst removePendingMessage = messageId => {\n  try {\n    const pendingMessages = getPendingMessages();\n    const updatedMessages = pendingMessages.filter(msg => msg.id !== messageId);\n    localStorage.setItem('whisperNetPendingMessages', JSON.stringify(updatedMessages));\n    return true;\n  } catch (error) {\n    console.error('Error removing pending message:', error);\n    return false;\n  }\n};\n\n// Clean up expired messages\nconst cleanupExpiredMessages = () => {\n  try {\n    const pendingMessages = getPendingMessages();\n    const validMessages = pendingMessages.filter(msg => !isMessageExpired(msg.ttl));\n    if (validMessages.length !== pendingMessages.length) {\n      localStorage.setItem('whisperNetPendingMessages', JSON.stringify(validMessages));\n      console.log(`Cleaned up ${pendingMessages.length - validMessages.length} expired messages`);\n    }\n    return validMessages;\n  } catch (error) {\n    console.error('Error cleaning up expired messages:', error);\n    return [];\n  }\n};\n\n// Track message delivery status\nconst trackMessageDelivery = (messageId, status) => {\n  try {\n    const pendingMessages = getPendingMessages();\n    const updatedMessages = pendingMessages.map(msg => {\n      if (msg.id === messageId) {\n        return {\n          ...msg,\n          delivered: status\n        };\n      }\n      return msg;\n    });\n    localStorage.setItem('whisperNetPendingMessages', JSON.stringify(updatedMessages));\n    return true;\n  } catch (error) {\n    console.error('Error tracking message delivery:', error);\n    return false;\n  }\n};\n\n// Increment bounce count for a message\nconst incrementBounceCount = messageId => {\n  try {\n    const pendingMessages = getPendingMessages();\n    const message = pendingMessages.find(msg => msg.id === messageId);\n    if (!message) return false;\n    if (message.bounceCount >= message.maxBounces) {\n      // Message has reached max bounces, mark for removal\n      removePendingMessage(messageId);\n      return false;\n    }\n    const updatedMessages = pendingMessages.map(msg => {\n      if (msg.id === messageId) {\n        return {\n          ...msg,\n          bounceCount: msg.bounceCount + 1\n        };\n      }\n      return msg;\n    });\n    localStorage.setItem('whisperNetPendingMessages', JSON.stringify(updatedMessages));\n    return true;\n  } catch (error) {\n    console.error('Error incrementing bounce count:', error);\n    return false;\n  }\n};\n\n// Store known device IDs for usernames\nconst storeKnownDevice = (username, deviceId) => {\n  try {\n    const knownDevices = getKnownDevices();\n    if (!knownDevices[username]) {\n      knownDevices[username] = [];\n    }\n\n    // Only add if not already known\n    if (!knownDevices[username].includes(deviceId)) {\n      knownDevices[username].push(deviceId);\n    }\n    localStorage.setItem('whisperNetKnownDevices', JSON.stringify(knownDevices));\n    return true;\n  } catch (error) {\n    console.error('Error storing known device:', error);\n    return false;\n  }\n};\n\n// Get all known devices\nconst getKnownDevices = () => {\n  try {\n    const devices = localStorage.getItem('whisperNetKnownDevices');\n    return devices ? JSON.parse(devices) : {};\n  } catch (error) {\n    console.error('Error retrieving known devices:', error);\n    return {};\n  }\n};\n\n// Check if a device is known for a username\nconst isKnownDevice = (username, deviceId) => {\n  try {\n    const knownDevices = getKnownDevices();\n    return knownDevices[username] && knownDevices[username].includes(deviceId);\n  } catch (error) {\n    console.error('Error checking known device:', error);\n    return false;\n  }\n};\n\n// Store encryption keys for contacts\nconst storeContactKey = (username, publicKey) => {\n  try {\n    const contactKeys = getContactKeys();\n    contactKeys[username] = publicKey;\n    localStorage.setItem('whisperNetContactKeys', JSON.stringify(contactKeys));\n    return true;\n  } catch (error) {\n    console.error('Error storing contact key:', error);\n    return false;\n  }\n};\n\n// Get all contact encryption keys\nconst getContactKeys = () => {\n  try {\n    const keys = localStorage.getItem('whisperNetContactKeys');\n    return keys ? JSON.parse(keys) : {};\n  } catch (error) {\n    console.error('Error retrieving contact keys:', error);\n    return {};\n  }\n};\n\n// Get a specific contact's encryption key\nconst getContactKey = username => {\n  try {\n    const contactKeys = getContactKeys();\n    return contactKeys[username] || null;\n  } catch (error) {\n    console.error('Error getting contact key:', error);\n    return null;\n  }\n};\n\n// Send message to recipient via relay\nconst sendMessage = async (message, relayUrl) => {\n  try {\n    const response = await axios.post(`${relayUrl}/message`, message, {\n      timeout: 5000\n    });\n    if (response.status === 200) {\n      return true;\n    }\n    return false;\n  } catch (error) {\n    console.error('Error sending message:', error);\n    return false;\n  }\n};\nexport { generateMessageId, calculateMessageTTL, calculateTTL, isMessageExpired, createRelayMessage, storePendingMessage, getPendingMessages, removePendingMessage, cleanupExpiredMessages, trackMessageDelivery, incrementBounceCount, storeKnownDevice, getKnownDevices, isKnownDevice, storeContactKey, getContactKeys, getContactKey, sendMessage };","map":{"version":3,"names":["generateMessageId","Date","now","toString","Math","random","substr","calculateMessageTTL","hours","calculateTTL","isMessageExpired","ttl","createRelayMessage","from","to","content","deviceId","encryptedContent","iv","id","fromDeviceId","timestamp","toISOString","encrypted","delivered","bounceCount","maxBounces","storePendingMessage","message","pendingMessages","getPendingMessages","push","localStorage","setItem","JSON","stringify","error","console","messages","getItem","parse","removePendingMessage","messageId","updatedMessages","filter","msg","cleanupExpiredMessages","validMessages","length","log","trackMessageDelivery","status","map","incrementBounceCount","find","storeKnownDevice","username","knownDevices","getKnownDevices","includes","devices","isKnownDevice","storeContactKey","publicKey","contactKeys","getContactKeys","keys","getContactKey","sendMessage","relayUrl","response","axios","post","timeout"],"sources":["C:/Users/siddharth/Documents/GitHub/WhisperNet/frontend/src/messageUtils.js"],"sourcesContent":["/**\n * WhisperNet Message Utilities\n * Handles message persistence, offline relay, and message tracking\n */\n\n// Generate a unique message ID\nconst generateMessageId = () => {\n  return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);\n};\n\n// Calculate message TTL (Time To Live) in milliseconds\n// Default: 4 hours = 14400000 ms\nconst calculateMessageTTL = (hours = 4) => {\n  return Date.now() + (hours * 60 * 60 * 1000);\n};\n\n// Alias for calculateMessageTTL for backward compatibility\nconst calculateTTL = calculateMessageTTL;\n\n// Check if a message has expired\nconst isMessageExpired = (ttl) => {\n  return Date.now() > ttl;\n};\n\n// Create a relay message with all necessary metadata\nconst createRelayMessage = (from, to, content, deviceId, encryptedContent, iv) => {\n  return {\n    id: generateMessageId(),\n    from,\n    to,\n    content: content || null, // Plain content (if not encrypted)\n    fromDeviceId: deviceId,\n    timestamp: new Date().toISOString(),\n    ttl: calculateMessageTTL(),\n    encrypted: !!encryptedContent,\n    encryptedContent,\n    iv,\n    delivered: false,\n    bounceCount: 0,\n    maxBounces: 10 // Maximum number of relay hops\n  };\n};\n\n// Store pending messages locally\nconst storePendingMessage = (message) => {\n  try {\n    const pendingMessages = getPendingMessages();\n    pendingMessages.push(message);\n    localStorage.setItem('whisperNetPendingMessages', JSON.stringify(pendingMessages));\n    return true;\n  } catch (error) {\n    console.error('Error storing pending message:', error);\n    return false;\n  }\n};\n\n// Get all pending messages\nconst getPendingMessages = () => {\n  try {\n    const messages = localStorage.getItem('whisperNetPendingMessages');\n    return messages ? JSON.parse(messages) : [];\n  } catch (error) {\n    console.error('Error retrieving pending messages:', error);\n    return [];\n  }\n};\n\n// Remove a pending message by ID\nconst removePendingMessage = (messageId) => {\n  try {\n    const pendingMessages = getPendingMessages();\n    const updatedMessages = pendingMessages.filter(msg => msg.id !== messageId);\n    localStorage.setItem('whisperNetPendingMessages', JSON.stringify(updatedMessages));\n    return true;\n  } catch (error) {\n    console.error('Error removing pending message:', error);\n    return false;\n  }\n};\n\n// Clean up expired messages\nconst cleanupExpiredMessages = () => {\n  try {\n    const pendingMessages = getPendingMessages();\n    const validMessages = pendingMessages.filter(msg => !isMessageExpired(msg.ttl));\n    \n    if (validMessages.length !== pendingMessages.length) {\n      localStorage.setItem('whisperNetPendingMessages', JSON.stringify(validMessages));\n      console.log(`Cleaned up ${pendingMessages.length - validMessages.length} expired messages`);\n    }\n    \n    return validMessages;\n  } catch (error) {\n    console.error('Error cleaning up expired messages:', error);\n    return [];\n  }\n};\n\n// Track message delivery status\nconst trackMessageDelivery = (messageId, status) => {\n  try {\n    const pendingMessages = getPendingMessages();\n    const updatedMessages = pendingMessages.map(msg => {\n      if (msg.id === messageId) {\n        return { ...msg, delivered: status };\n      }\n      return msg;\n    });\n    \n    localStorage.setItem('whisperNetPendingMessages', JSON.stringify(updatedMessages));\n    return true;\n  } catch (error) {\n    console.error('Error tracking message delivery:', error);\n    return false;\n  }\n};\n\n// Increment bounce count for a message\nconst incrementBounceCount = (messageId) => {\n  try {\n    const pendingMessages = getPendingMessages();\n    const message = pendingMessages.find(msg => msg.id === messageId);\n    \n    if (!message) return false;\n    \n    if (message.bounceCount >= message.maxBounces) {\n      // Message has reached max bounces, mark for removal\n      removePendingMessage(messageId);\n      return false;\n    }\n    \n    const updatedMessages = pendingMessages.map(msg => {\n      if (msg.id === messageId) {\n        return { ...msg, bounceCount: msg.bounceCount + 1 };\n      }\n      return msg;\n    });\n    \n    localStorage.setItem('whisperNetPendingMessages', JSON.stringify(updatedMessages));\n    return true;\n  } catch (error) {\n    console.error('Error incrementing bounce count:', error);\n    return false;\n  }\n};\n\n// Store known device IDs for usernames\nconst storeKnownDevice = (username, deviceId) => {\n  try {\n    const knownDevices = getKnownDevices();\n    \n    if (!knownDevices[username]) {\n      knownDevices[username] = [];\n    }\n    \n    // Only add if not already known\n    if (!knownDevices[username].includes(deviceId)) {\n      knownDevices[username].push(deviceId);\n    }\n    \n    localStorage.setItem('whisperNetKnownDevices', JSON.stringify(knownDevices));\n    return true;\n  } catch (error) {\n    console.error('Error storing known device:', error);\n    return false;\n  }\n};\n\n// Get all known devices\nconst getKnownDevices = () => {\n  try {\n    const devices = localStorage.getItem('whisperNetKnownDevices');\n    return devices ? JSON.parse(devices) : {};\n  } catch (error) {\n    console.error('Error retrieving known devices:', error);\n    return {};\n  }\n};\n\n// Check if a device is known for a username\nconst isKnownDevice = (username, deviceId) => {\n  try {\n    const knownDevices = getKnownDevices();\n    return knownDevices[username] && knownDevices[username].includes(deviceId);\n  } catch (error) {\n    console.error('Error checking known device:', error);\n    return false;\n  }\n};\n\n// Store encryption keys for contacts\nconst storeContactKey = (username, publicKey) => {\n  try {\n    const contactKeys = getContactKeys();\n    contactKeys[username] = publicKey;\n    localStorage.setItem('whisperNetContactKeys', JSON.stringify(contactKeys));\n    return true;\n  } catch (error) {\n    console.error('Error storing contact key:', error);\n    return false;\n  }\n};\n\n// Get all contact encryption keys\nconst getContactKeys = () => {\n  try {\n    const keys = localStorage.getItem('whisperNetContactKeys');\n    return keys ? JSON.parse(keys) : {};\n  } catch (error) {\n    console.error('Error retrieving contact keys:', error);\n    return {};\n  }\n};\n\n// Get a specific contact's encryption key\nconst getContactKey = (username) => {\n  try {\n    const contactKeys = getContactKeys();\n    return contactKeys[username] || null;\n  } catch (error) {\n    console.error('Error getting contact key:', error);\n    return null;\n  }\n};\n\n// Send message to recipient via relay\nconst sendMessage = async (message, relayUrl) => {\n  try {\n    const response = await axios.post(`${relayUrl}/message`, message, {\n      timeout: 5000\n    });\n    \n    if (response.status === 200) {\n      return true;\n    }\n    return false;\n  } catch (error) {\n    console.error('Error sending message:', error);\n    return false;\n  }\n};\n\nexport {\n  generateMessageId,\n  calculateMessageTTL,\n  calculateTTL,\n  isMessageExpired,\n  createRelayMessage,\n  storePendingMessage,\n  getPendingMessages,\n  removePendingMessage,\n  cleanupExpiredMessages,\n  trackMessageDelivery,\n  incrementBounceCount,\n  storeKnownDevice,\n  getKnownDevices,\n  isKnownDevice,\n  storeContactKey,\n  getContactKeys,\n  getContactKey,\n  sendMessage\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}